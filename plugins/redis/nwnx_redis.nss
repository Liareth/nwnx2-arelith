// Autogenerated on: 2015-11-30 15:31:05 +0100
#include "nwnx_redis_core"

// Skipping sub-command: CLIENT KILL/{"command"=>"TYPE", "type"=>"enum", "enum"=>["normal", "slave", "pubsub"], "optional"=>true} - not supported yet.
/**
 * APPEND
 *
 * Append a value to a key
 *
 * Time complexity: O(1). The amortized time complexity is O(1) assuming the appended value is
 * small and the already present value is of any size, since the dynamic string
 * library used by Redis will double the free space available on every
 * reallocation.
 * Annotated return value: integer
 */
int APPEND(
	string key,
	string value
);

/**
 * AUTH
 *
 * Authenticate to the server
 * Annotated return value: simple-string
 */
string AUTH(
	string password
);

/**
 * BGREWRITEAOF
 *
 * Asynchronously rewrite the append-only file
 * Annotated return value: simple-string
 */
string BGREWRITEAOF();

/**
 * BGSAVE
 *
 * Asynchronously save the dataset to disk
 * Annotated return value: simple-string
 */
string BGSAVE();

/**
 * BITCOUNT
 *
 * Count set bits in a string
 *
 * Time complexity: O(N)
 * Annotated return value: integer
 */
int BITCOUNT(
	string key,
	// Redis type: integer
	int start = 0,
	// Redis type: integer
	int end = 0
);

/**
 * BITOP
 *
 * Perform bitwise operations between strings
 *
 * Time complexity: O(N)
 * Annotated return value: integer
 */
int BITOP(
	string operation,
	// Redis type: key
	string destkey,
	string key
);

/**
 * BITPOS
 *
 * Find first bit set or clear in a string
 *
 * Time complexity: O(N)
 * Annotated return value: integer
 */
int BITPOS(
	string key,
	// Redis type: integer
	int bit,
	// Redis type: integer
	int start = 0,
	// Redis type: integer
	int end = 0
);

/**
 * BLPOP
 *
 * Remove and get the first element in a list, or block until one is available
 *
 * Time complexity: O(1)
 * Annotated return value: array
 */
int BLPOP(
	string key,
	// Redis type: integer
	int timeout
);

/**
 * BRPOP
 *
 * Remove and get the last element in a list, or block until one is available
 *
 * Time complexity: O(1)
 * Annotated return value: array
 */
int BRPOP(
	string key,
	// Redis type: integer
	int timeout
);

/**
 * BRPOPLPUSH
 *
 * Pop a value from a list, push it to another list and return it; or block until one is available
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string BRPOPLPUSH(
	// Redis type: key
	string source,
	// Redis type: key
	string destination,
	// Redis type: integer
	int timeout
);

/**
 * CLIENT KILL
 *
 * Kill the connection of a client
 *
 * Time complexity: O(N) where N is the number of client connections
 * Annotated return value: simple-string
 */
string CLIENT_KILL(
	string ip_port = "",
	// Redis type: integer
	int client_id = 0,
	Skipping sub-command: CLIENT KILL/{"command"=>"TYPE", "type"=>"enum", "enum"=>["normal", "slave", "pubsub"], "optional"=>true} - not supported yet.  = "",
	string ip_port = "",
	string yes_no = ""
);

/**
 * CLIENT LIST
 *
 * Get the list of client connections
 *
 * Time complexity: O(N) where N is the number of client connections
 * Annotated return value: bulk-string
 */
string CLIENT_LIST();

/**
 * CLIENT GETNAME
 *
 * Get the current connection name
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string CLIENT_GETNAME();

/**
 * CLIENT PAUSE
 *
 * Stop processing commands from clients for some time
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLIENT_PAUSE(
	// Redis type: integer
	int timeout
);

/**
 * CLIENT SETNAME
 *
 * Set the current connection name
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLIENT_SETNAME(
	string connection_name
);

/**
 * CLUSTER ADDSLOTS
 *
 * Assign new hash slots to receiving node
 *
 * Time complexity: O(N) where N is the total number of hash slot arguments
 * Annotated return value: simple-string
 */
string CLUSTER_ADDSLOTS(
	// Redis type: integer
	int slot
);

/**
 * CLUSTER COUNT_FAILURE_REPORTS
 *
 * Return the number of failure reports active for a given node
 *
 * Time complexity: O(N) where N is the number of failure reports
 * Annotated return value: 
 */
string CLUSTER_COUNT_FAILURE_REPORTS(
	string node_id
);

/**
 * CLUSTER COUNTKEYSINSLOT
 *
 * Return the number of local keys in the specified hash slot
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int CLUSTER_COUNTKEYSINSLOT(
	// Redis type: integer
	int slot
);

/**
 * CLUSTER DELSLOTS
 *
 * Set hash slots as unbound in receiving node
 *
 * Time complexity: O(N) where N is the total number of hash slot arguments
 * Annotated return value: simple-string
 */
string CLUSTER_DELSLOTS(
	// Redis type: integer
	int slot
);

/**
 * CLUSTER FAILOVER
 *
 * Forces a slave to perform a manual failover of its master.
 *
 * Time complexity: O(1)

 * - Valid values for options: "FORCE", "TAKEOVER"
 * Annotated return value: simple-string
 */
string CLUSTER_FAILOVER(
	// Redis type: enum
	string options = ""
);

/**
 * CLUSTER FORGET
 *
 * Remove a node from the nodes table
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLUSTER_FORGET(
	string node_id
);

/**
 * CLUSTER GETKEYSINSLOT
 *
 * Return local key names in the specified hash slot
 *
 * Time complexity: O(log(N)) where N is the number of requested keys
 * Annotated return value: array
 */
int CLUSTER_GETKEYSINSLOT(
	// Redis type: integer
	int slot,
	// Redis type: integer
	int count
);

/**
 * CLUSTER INFO
 *
 * Provides info about Redis Cluster node state
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string CLUSTER_INFO();

/**
 * CLUSTER KEYSLOT
 *
 * Returns the hash slot of the specified key
 *
 * Time complexity: O(N) where N is the number of bytes in the key
 * Annotated return value: integer
 */
int CLUSTER_KEYSLOT(
	string key
);

/**
 * CLUSTER MEET
 *
 * Force a node cluster to handshake with another node
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLUSTER_MEET(
	string ip,
	// Redis type: integer
	int port
);

/**
 * CLUSTER NODES
 *
 * Get Cluster config for the node
 *
 * Time complexity: O(N) where N is the total number of Cluster nodes
 * Annotated return value: bulk-string
 */
string CLUSTER_NODES();

/**
 * CLUSTER REPLICATE
 *
 * Reconfigure a node as a slave of the specified master node
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLUSTER_REPLICATE(
	string node_id
);

/**
 * CLUSTER RESET
 *
 * Reset a Redis Cluster node
 *
 * Time complexity: O(N) where N is the number of known nodes. The command may execute a
 * FLUSHALL as a side effect.

 * - Valid values for reset_type: "HARD", "SOFT"
 * Annotated return value: simple-string
 */
string CLUSTER_RESET(
	// Redis type: enum
	string reset_type = ""
);

/**
 * CLUSTER SAVECONFIG
 *
 * Forces the node to save cluster state on disk
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLUSTER_SAVECONFIG();

/**
 * CLUSTER SET_CONFIG_EPOCH
 *
 * Set the configuration epoch in a new node
 *
 * Time complexity: O(1)
 * Annotated return value: 
 */
string CLUSTER_SET_CONFIG_EPOCH(
	// Redis type: integer
	int config_epoch
);

/**
 * CLUSTER SETSLOT
 *
 * Bind an hash slot to a specific node
 *
 * Time complexity: O(1)

 * - Valid values for subcommand: "IMPORTING", "MIGRATING", "STABLE", "NODE"
 * Annotated return value: simple-string
 */
string CLUSTER_SETSLOT(
	// Redis type: integer
	int slot,
	// Redis type: enum
	string subcommand,
	string node_id = ""
);

/**
 * CLUSTER SLAVES
 *
 * List slave nodes of the specified master node
 *
 * Time complexity: O(1)
 * Annotated return value: 
 */
string CLUSTER_SLAVES(
	string node_id
);

/**
 * CLUSTER SLOTS
 *
 * Get array of Cluster slot to node mappings
 *
 * Time complexity: O(N) where N is the total number of Cluster nodes
 * Annotated return value: array
 */
int CLUSTER_SLOTS();

/**
 * COMMAND
 *
 * Get array of Redis command details
 *
 * Time complexity: O(N) where N is the total number of Redis commands
 * Annotated return value: array
 */
int COMMAND();

/**
 * COMMAND COUNT
 *
 * Get total number of Redis commands
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int COMMAND_COUNT();

/**
 * COMMAND GETKEYS
 *
 * Extract keys given a full Redis command
 *
 * Time complexity: O(N) where N is the number of arguments to the command
 * Annotated return value: array
 */
int COMMAND_GETKEYS();

/**
 * COMMAND INFO
 *
 * Get array of specific Redis command details
 *
 * Time complexity: O(N) when N is number of commands to look up
 * Annotated return value: array
 */
int COMMAND_INFO(
	string command_name
);

/**
 * CONFIG GET
 *
 * Get the value of a configuration parameter
 * Annotated return value: array
 */
int CONFIG_GET(
	string parameter
);

/**
 * CONFIG REWRITE
 *
 * Rewrite the configuration file with the in memory configuration
 * Annotated return value: simple-string
 */
string CONFIG_REWRITE();

/**
 * CONFIG SET
 *
 * Set a configuration parameter to the given value
 * Annotated return value: simple-string
 */
string CONFIG_SET(
	string parameter,
	string value
);

/**
 * CONFIG RESETSTAT
 *
 * Reset the stats returned by INFO
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CONFIG_RESETSTAT();

/**
 * DBSIZE
 *
 * Return the number of keys in the selected database
 * Annotated return value: integer
 */
int DBSIZE();

/**
 * DEBUG OBJECT
 *
 * Get debugging information about a key
 * Annotated return value: simple-string
 */
string DEBUG_OBJECT(
	string key
);

/**
 * DEBUG SEGFAULT
 *
 * Make the server crash
 * Annotated return value: simple-string
 */
string DEBUG_SEGFAULT();

/**
 * DECR
 *
 * Decrement the integer value of a key by one
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int DECR(
	string key
);

/**
 * DECRBY
 *
 * Decrement the integer value of a key by the given number
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int DECRBY(
	string key,
	// Redis type: integer
	int decrement
);

/**
 * DEL
 *
 * Delete a key
 *
 * Time complexity: O(N) where N is the number of keys that will be removed. When a key to
 * remove holds a value other than a string, the individual complexity for this
 * key is O(M) where M is the number of elements in the list, set, sorted set
 * or hash. Removing a single key that holds a string value is O(1).
 * Annotated return value: integer
 */
int DEL(
	string key
);

/**
 * DISCARD
 *
 * Discard all commands issued after MULTI
 * Annotated return value: simple-string
 */
string DISCARD();

/**
 * DUMP
 *
 * Return a serialized version of the value stored at the specified key.
 *
 * Time complexity: O(1) to access the key and additional O(N*M) to serialized it, where N is
 * the number of Redis objects composing the value and M their average size.
 * For small string values the time complexity is thus O(1)+O(1*M) where M is
 * small, so simply O(1).
 * Annotated return value: bulk-string
 */
string DUMP(
	string key
);

/**
 * ECHO
 *
 * Echo the given string
 * Annotated return value: bulk-string
 */
string ECHO(
	string message
);

/**
 * EVAL
 *
 * Execute a Lua script server side
 *
 * Time complexity: Depends on the script that is executed.
 * Annotated return value: 
 */
string EVAL(
	string script,
	// Redis type: integer
	int numkeys,
	string key,
	string arg
);

/**
 * EVALSHA
 *
 * Execute a Lua script server side
 *
 * Time complexity: Depends on the script that is executed.
 * Annotated return value: 
 */
string EVALSHA(
	string sha1,
	// Redis type: integer
	int numkeys,
	string key,
	string arg
);

/**
 * EXEC
 *
 * Execute all commands issued after MULTI
 * Annotated return value: array
 */
int EXEC();

/**
 * EXISTS
 *
 * Determine if a key exists
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int EXISTS(
	string key
);

/**
 * EXPIRE
 *
 * Set a key's time to live in seconds
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int EXPIRE(
	string key,
	// Redis type: integer
	int seconds
);

/**
 * EXPIREAT
 *
 * Set the expiration for a key as a UNIX timestamp
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int EXPIREAT(
	string key,
	// Redis type: posix time
	string timestamp
);

/**
 * FLUSHALL
 *
 * Remove all keys from all databases
 * Annotated return value: simple-string
 */
string FLUSHALL();

/**
 * FLUSHDB
 *
 * Remove all keys from the current database
 * Annotated return value: simple-string
 */
string FLUSHDB();

/**
 * GEOADD
 *
 * Add one or more geospatial items in the geospatial index represented using a sorted set
 *
 * Time complexity: O(log(N)) for each item added, where N is the number of elements in the
 * sorted set.
 * Annotated return value: integer
 */
int GEOADD(
	string key,
	// Redis type: double
	float longitude,
	// Redis type: double
	float latitude,
	string member
);

/**
 * GEOHASH
 *
 * Returns members of a geospatial index as standard geohash strings
 *
 * Time complexity: O(log(N)) for each member requested, where N is the number of elements in
 * the sorted set.
 * Annotated return value: array
 */
int GEOHASH(
	string key,
	string member
);

/**
 * GEOPOS
 *
 * Returns longitude and latitude of members of a geospatial index
 *
 * Time complexity: O(log(N)) for each member requested, where N is the number of elements in
 * the sorted set.
 * Annotated return value: array
 */
int GEOPOS(
	string key,
	string member
);

/**
 * GEODIST
 *
 * Returns the distance between two members of a geospatial index
 *
 * Time complexity: O(log(N))
 * Annotated return value: bulk-string
 */
string GEODIST(
	string key,
	string member1,
	string member2,
	string unit = ""
);

/**
 * GEORADIUS
 *
 * Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point
 *
 * Time complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the
 * circular area delimited by center and radius and M is the number of items
 * inside the index.

 * - Valid values for unit: "m", "km", "ft", "mi"

 * - Valid values for withcoord: "WITHCOORD"

 * - Valid values for withdist: "WITHDIST"

 * - Valid values for withhash: "WITHHASH"
 * Annotated return value: array
 */
int GEORADIUS(
	string key,
	// Redis type: double
	float longitude,
	// Redis type: double
	float latitude,
	// Redis type: double
	float radius,
	// Redis type: enum
	string unit,
	// Redis type: enum
	string withcoord = "",
	// Redis type: enum
	string withdist = "",
	// Redis type: enum
	string withhash = ""
);

/**
 * GEORADIUSBYMEMBER
 *
 * Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member
 *
 * Time complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the
 * circular area delimited by center and radius and M is the number of items
 * inside the index.

 * - Valid values for unit: "m", "km", "ft", "mi"

 * - Valid values for withcoord: "WITHCOORD"

 * - Valid values for withdist: "WITHDIST"

 * - Valid values for withhash: "WITHHASH"
 * Annotated return value: 
 */
string GEORADIUSBYMEMBER(
	string key,
	string member,
	// Redis type: double
	float radius,
	// Redis type: enum
	string unit,
	// Redis type: enum
	string withcoord = "",
	// Redis type: enum
	string withdist = "",
	// Redis type: enum
	string withhash = ""
);

/**
 * GET
 *
 * Get the value of a key
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string GET(
	string key
);

/**
 * GETBIT
 *
 * Returns the bit value at offset in the string value stored at key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int GETBIT(
	string key,
	// Redis type: integer
	int offset
);

/**
 * GETRANGE
 *
 * Get a substring of the string stored at a key
 *
 * Time complexity: O(N) where N is the length of the returned string. The complexity is
 * ultimately determined by the returned length, but because creating a
 * substring from an existing string is very cheap, it can be considered O(1)
 * for small strings.
 * Annotated return value: bulk-string
 */
string GETRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int end
);

/**
 * GETSET
 *
 * Set the string value of a key and return its old value
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string GETSET(
	string key,
	string value
);

/**
 * HDEL
 *
 * Delete one or more hash fields
 *
 * Time complexity: O(N) where N is the number of fields to be removed.
 * Annotated return value: integer
 */
int HDEL(
	string key,
	string field
);

/**
 * HEXISTS
 *
 * Determine if a hash field exists
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int HEXISTS(
	string key,
	string field
);

/**
 * HGET
 *
 * Get the value of a hash field
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string HGET(
	string key,
	string field
);

/**
 * HGETALL
 *
 * Get all the fields and values in a hash
 *
 * Time complexity: O(N) where N is the size of the hash.
 * Annotated return value: array
 */
int HGETALL(
	string key
);

/**
 * HINCRBY
 *
 * Increment the integer value of a hash field by the given number
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int HINCRBY(
	string key,
	string field,
	// Redis type: integer
	int increment
);

/**
 * HINCRBYFLOAT
 *
 * Increment the float value of a hash field by the given amount
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string HINCRBYFLOAT(
	string key,
	string field,
	// Redis type: double
	float increment
);

/**
 * HKEYS
 *
 * Get all the fields in a hash
 *
 * Time complexity: O(N) where N is the size of the hash.
 * Annotated return value: array
 */
int HKEYS(
	string key
);

/**
 * HLEN
 *
 * Get the number of fields in a hash
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int HLEN(
	string key
);

/**
 * HMGET
 *
 * Get the values of all the given hash fields
 *
 * Time complexity: O(N) where N is the number of fields being requested.
 * Annotated return value: array
 */
int HMGET(
	string key,
	string field
);

/**
 * HMSET
 *
 * Set multiple hash fields to multiple values
 *
 * Time complexity: O(N) where N is the number of fields being set.
 * Annotated return value: simple-string
 */
string HMSET(
	string key,
	string field,
	string value
);

/**
 * HSET
 *
 * Set the string value of a hash field
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int HSET(
	string key,
	string field,
	string value
);

/**
 * HSETNX
 *
 * Set the value of a hash field, only if the field does not exist
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int HSETNX(
	string key,
	string field,
	string value
);

/**
 * HSTRLEN
 *
 * Get the length of the value of a hash field
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int HSTRLEN(
	string key,
	string field
);

/**
 * HVALS
 *
 * Get all the values in a hash
 *
 * Time complexity: O(N) where N is the size of the hash.
 * Annotated return value: array
 */
int HVALS(
	string key
);

/**
 * INCR
 *
 * Increment the integer value of a key by one
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int INCR(
	string key
);

/**
 * INCRBY
 *
 * Increment the integer value of a key by the given amount
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int INCRBY(
	string key,
	// Redis type: integer
	int increment
);

/**
 * INCRBYFLOAT
 *
 * Increment the float value of a key by the given amount
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string INCRBYFLOAT(
	string key,
	// Redis type: double
	float increment
);

/**
 * INFO
 *
 * Get information and statistics about the server
 * Annotated return value: bulk-string
 */
string INFO(
	string section = ""
);

/**
 * KEYS
 *
 * Find all keys matching the given pattern
 *
 * Time complexity: O(N) with N being the number of keys in the database, under the assumption
 * that the key names in the database and the given pattern have limited
 * length.
 * Annotated return value: array
 */
int KEYS(
	string pattern
);

/**
 * LASTSAVE
 *
 * Get the UNIX time stamp of the last successful save to disk
 * Annotated return value: integer
 */
int LASTSAVE();

/**
 * LINDEX
 *
 * Get an element from a list by its index
 *
 * Time complexity: O(N) where N is the number of elements to traverse to get to the element at
 * index. This makes asking for the first or the last element of the list O(1).
 * Annotated return value: bulk-string
 */
string LINDEX(
	string key,
	// Redis type: integer
	int index
);

/**
 * LINSERT
 *
 * Insert an element before or after another element in a list
 *
 * Time complexity: O(N) where N is the number of elements to traverse before seeing the value
 * pivot. This means that inserting somewhere on the left end on the list
 * (head) can be considered O(1) and inserting somewhere on the right end
 * (tail) is O(N).

 * - Valid values for where: "BEFORE", "AFTER"
 * Annotated return value: integer
 */
int LINSERT(
	string key,
	// Redis type: enum
	string where,
	string pivot,
	string value
);

/**
 * LLEN
 *
 * Get the length of a list
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int LLEN(
	string key
);

/**
 * LPOP
 *
 * Remove and get the first element in a list
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string LPOP(
	string key
);

/**
 * LPUSH
 *
 * Prepend one or multiple values to a list
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int LPUSH(
	string key,
	string value
);

/**
 * LPUSHX
 *
 * Prepend a value to a list, only if the list exists
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int LPUSHX(
	string key,
	string value
);

/**
 * LRANGE
 *
 * Get a range of elements from a list
 *
 * Time complexity: O(S+N) where S is the distance of start offset from HEAD for small lists,
 * from nearest end (HEAD or TAIL) for large lists; and N is the number of
 * elements in the specified range.
 * Annotated return value: array
 */
int LRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop
);

/**
 * LREM
 *
 * Remove elements from a list
 *
 * Time complexity: O(N) where N is the length of the list.
 * Annotated return value: integer
 */
int LREM(
	string key,
	// Redis type: integer
	int count,
	string value
);

/**
 * LSET
 *
 * Set the value of an element in a list by its index
 *
 * Time complexity: O(N) where N is the length of the list. Setting either the first or the last
 * element of the list is O(1).
 * Annotated return value: simple-string
 */
string LSET(
	string key,
	// Redis type: integer
	int index,
	string value
);

/**
 * LTRIM
 *
 * Trim a list to the specified range
 *
 * Time complexity: O(N) where N is the number of elements to be removed by the operation.
 * Annotated return value: simple-string
 */
string LTRIM(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop
);

/**
 * MGET
 *
 * Get the values of all the given keys
 *
 * Time complexity: O(N) where N is the number of keys to retrieve.
 * Annotated return value: array
 */
int MGET(
	string key
);

/**
 * MIGRATE
 *
 * Atomically transfer a key from a Redis instance to another one.
 *
 * Time complexity: This command actually executes a DUMP+DEL in the source instance, and a
 * RESTORE in the target instance. See the pages of these commands for time
 * complexity. Also an O(N) data transfer between the two instances is
 * performed.

 * - Valid values for copy: "COPY"

 * - Valid values for replace: "REPLACE"
 * Annotated return value: simple-string
 */
string MIGRATE(
	string host,
	string port,
	string key,
	// Redis type: integer
	int destination_db,
	// Redis type: integer
	int timeout,
	// Redis type: enum
	string copy = "",
	// Redis type: enum
	string replace = ""
);

/**
 * MONITOR
 *
 * Listen for all requests received by the server in real time
 * Annotated return value: 
 */
string MONITOR();

/**
 * MOVE
 *
 * Move a key to another database
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int MOVE(
	string key,
	// Redis type: integer
	int db
);

/**
 * MSET
 *
 * Set multiple keys to multiple values
 *
 * Time complexity: O(N) where N is the number of keys to set.
 * Annotated return value: simple-string
 */
string MSET(
	string key,
	string value
);

/**
 * MSETNX
 *
 * Set multiple keys to multiple values, only if none of the keys exist
 *
 * Time complexity: O(N) where N is the number of keys to set.
 * Annotated return value: integer
 */
int MSETNX(
	string key,
	string value
);

/**
 * MULTI
 *
 * Mark the start of a transaction block
 * Annotated return value: simple-string
 */
string MULTI();

/**
 * OBJECT
 *
 * Inspect the internals of Redis objects
 *
 * Time complexity: O(1) for all the currently implemented subcommands.
 * Annotated return value: 
 */
string OBJECT(
	string subcommand,
	string arguments = ""
);

/**
 * PERSIST
 *
 * Remove the expiration from a key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int PERSIST(
	string key
);

/**
 * PEXPIRE
 *
 * Set a key's time to live in milliseconds
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int PEXPIRE(
	string key,
	// Redis type: integer
	int milliseconds
);

/**
 * PEXPIREAT
 *
 * Set the expiration for a key as a UNIX timestamp specified in milliseconds
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int PEXPIREAT(
	string key,
	// Redis type: posix time
	string milliseconds_timestamp
);

/**
 * PFADD
 *
 * Adds the specified elements to the specified HyperLogLog.
 *
 * Time complexity: O(1) to add every element.
 * Annotated return value: integer
 */
int PFADD(
	string key,
	string element
);

/**
 * PFCOUNT
 *
 * Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).
 *
 * Time complexity: O(1) with every small average constant times when called with a single key.
 * O(N) with N being the number of keys, and much bigger constant times, when
 * called with multiple keys.
 * Annotated return value: integer
 */
int PFCOUNT(
	string key
);

/**
 * PFMERGE
 *
 * Merge N different HyperLogLogs into a single one.
 *
 * Time complexity: O(N) to merge N HyperLogLogs, but with high constant times.
 * Annotated return value: simple-string
 */
string PFMERGE(
	// Redis type: key
	string destkey,
	// Redis type: key
	string sourcekey
);

/**
 * PING
 *
 * Ping the server
 * Annotated return value: simple-string
 */
string PING();

/**
 * PSETEX
 *
 * Set the value and expiration in milliseconds of a key
 *
 * Time complexity: O(1)
 * Annotated return value: 
 */
string PSETEX(
	string key,
	// Redis type: integer
	int milliseconds,
	string value
);

/**
 * PUBSUB
 *
 * Inspect the state of the Pub/Sub subsystem
 *
 * Time complexity: O(N) for the CHANNELS subcommand, where N is the number of active channels,
 * and assuming constant time pattern matching (relatively short channels and
 * patterns). O(N) for the NUMSUB subcommand, where N is the number of
 * requested channels. O(1) for the NUMPAT subcommand.
 * Annotated return value: array
 */
int PUBSUB(
	string subcommand,
	string argument = ""
);

/**
 * PTTL
 *
 * Get the time to live for a key in milliseconds
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int PTTL(
	string key
);

/**
 * PUBLISH
 *
 * Post a message to a channel
 *
 * Time complexity: O(N+M) where N is the number of clients subscribed to the receiving channel
 * and M is the total number of subscribed patterns (by any client).
 * Annotated return value: integer
 */
int PUBLISH(
	string channel,
	string message
);

/**
 * QUIT
 *
 * Close the connection
 * Annotated return value: simple-string
 */
string QUIT();

/**
 * RANDOMKEY
 *
 * Return a random key from the keyspace
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string RANDOMKEY();

/**
 * RENAME
 *
 * Rename a key
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string RENAME(
	string key,
	// Redis type: key
	string newkey
);

/**
 * RENAMENX
 *
 * Rename a key, only if the new key does not exist
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int RENAMENX(
	string key,
	// Redis type: key
	string newkey
);

/**
 * RESTORE
 *
 * Create a key using the provided serialized value, previously obtained using DUMP.
 *
 * Time complexity: O(1) to create the new key and additional O(N*M) to reconstruct the
 * serialized value, where N is the number of Redis objects composing the value
 * and M their average size. For small string values the time complexity is
 * thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set
 * values the complexity is O(N*M*log(N)) because inserting values into sorted
 * sets is O(log(N)).

 * - Valid values for replace: "REPLACE"
 * Annotated return value: simple-string
 */
string RESTORE(
	string key,
	// Redis type: integer
	int ttl,
	string serialized_value,
	// Redis type: enum
	string replace = ""
);

/**
 * ROLE
 *
 * Return the role of the instance in the context of replication
 * Annotated return value: array
 */
int ROLE();

/**
 * RPOP
 *
 * Remove and get the last element in a list
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string RPOP(
	string key
);

/**
 * RPOPLPUSH
 *
 * Remove the last element in a list, prepend it to another list and return it
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string RPOPLPUSH(
	// Redis type: key
	string source,
	// Redis type: key
	string destination
);

/**
 * RPUSH
 *
 * Append one or multiple values to a list
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int RPUSH(
	string key,
	string value
);

/**
 * RPUSHX
 *
 * Append a value to a list, only if the list exists
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int RPUSHX(
	string key,
	string value
);

/**
 * SADD
 *
 * Add one or more members to a set
 *
 * Time complexity: O(N) where N is the number of members to be added.
 * Annotated return value: integer
 */
int SADD(
	string key,
	string member
);

/**
 * SAVE
 *
 * Synchronously save the dataset to disk
 * Annotated return value: simple-string
 */
string SAVE();

/**
 * SCARD
 *
 * Get the number of members in a set
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int SCARD(
	string key
);

/**
 * SCRIPT EXISTS
 *
 * Check existence of scripts in the script cache.
 *
 * Time complexity: O(N) with N being the number of scripts to check (so checking a single
 * script is an O(1) operation).
 * Annotated return value: array
 */
int SCRIPT_EXISTS(
	string script
);

/**
 * SCRIPT FLUSH
 *
 * Remove all the scripts from the script cache.
 *
 * Time complexity: O(N) with N being the number of scripts in cache
 * Annotated return value: simple-string
 */
string SCRIPT_FLUSH();

/**
 * SCRIPT KILL
 *
 * Kill the script currently in execution.
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string SCRIPT_KILL();

/**
 * SCRIPT LOAD
 *
 * Load the specified Lua script into the script cache.
 *
 * Time complexity: O(N) with N being the length in bytes of the script body.
 * Annotated return value: bulk-string
 */
string SCRIPT_LOAD(
	string script
);

/**
 * SDIFF
 *
 * Subtract multiple sets
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 * Annotated return value: array
 */
int SDIFF(
	string key
);

/**
 * SDIFFSTORE
 *
 * Subtract multiple sets and store the resulting set in a key
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 * Annotated return value: integer
 */
int SDIFFSTORE(
	// Redis type: key
	string destination,
	string key
);

/**
 * SELECT
 *
 * Change the selected database for the current connection
 * Annotated return value: simple-string
 */
string SELECT(
	// Redis type: integer
	int index
);

/**
 * SET
 *
 * Set the string value of a key
 *
 * Time complexity: O(1)

 * - Valid values for condition: "NX", "XX"
 * Annotated return value: simple-string
 */
string SET(
	string key,
	string value,
	// Redis type: integer
	int seconds = 0,
	// Redis type: integer
	int milliseconds = 0,
	// Redis type: enum
	string condition = ""
);

/**
 * SETBIT
 *
 * Sets or clears the bit at offset in the string value stored at key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int SETBIT(
	string key,
	// Redis type: integer
	int offset,
	string value
);

/**
 * SETEX
 *
 * Set the value and expiration of a key
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string SETEX(
	string key,
	// Redis type: integer
	int seconds,
	string value
);

/**
 * SETNX
 *
 * Set the value of a key, only if the key does not exist
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int SETNX(
	string key,
	string value
);

/**
 * SETRANGE
 *
 * Overwrite part of a string at key starting at the specified offset
 *
 * Time complexity: O(1), not counting the time taken to copy the new string in place. Usually,
 * this string is very small so the amortized complexity is O(1). Otherwise,
 * complexity is O(M) with M being the length of the value argument.
 * Annotated return value: integer
 */
int SETRANGE(
	string key,
	// Redis type: integer
	int offset,
	string value
);

/**
 * SHUTDOWN
 *
 * Synchronously save the dataset to disk and then shut down the server

 * - Valid values for NOSAVE: "NOSAVE"

 * - Valid values for SAVE: "SAVE"
 * Annotated return value: simple-string
 */
string SHUTDOWN(
	// Redis type: enum
	string NOSAVE = "",
	// Redis type: enum
	string SAVE = ""
);

/**
 * SINTER
 *
 * Intersect multiple sets
 *
 * Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is
 * the number of sets.
 * Annotated return value: array
 */
int SINTER(
	string key
);

/**
 * SINTERSTORE
 *
 * Intersect multiple sets and store the resulting set in a key
 *
 * Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is
 * the number of sets.
 * Annotated return value: integer
 */
int SINTERSTORE(
	// Redis type: key
	string destination,
	string key
);

/**
 * SISMEMBER
 *
 * Determine if a given value is a member of a set
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int SISMEMBER(
	string key,
	string member
);

/**
 * SLAVEOF
 *
 * Make the server a slave of another instance, or promote it as master
 * Annotated return value: simple-string
 */
string SLAVEOF(
	string host,
	string port
);

/**
 * SLOWLOG
 *
 * Manages the Redis slow queries log
 * Annotated return value: 
 */
string SLOWLOG(
	string subcommand,
	string argument = ""
);

/**
 * SMEMBERS
 *
 * Get all the members in a set
 *
 * Time complexity: O(N) where N is the set cardinality.
 * Annotated return value: array
 */
int SMEMBERS(
	string key
);

/**
 * SMOVE
 *
 * Move a member from one set to another
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int SMOVE(
	// Redis type: key
	string source,
	// Redis type: key
	string destination,
	string member
);

/**
 * SORT
 *
 * Sort the elements in a list, set or sorted set
 *
 * Time complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort,
 * and M the number of returned elements. When the elements are not sorted,
 * complexity is currently O(N) as there is a copy step that will be avoided in
 * next releases.

 * - Valid values for order: "ASC", "DESC"

 * - Valid values for sorting: "ALPHA"
 * Annotated return value: array
 */
int SORT(
	string key,
	string pattern = "",
	// Redis type: integer
	int offset = 0,
	// Redis type: integer
	int count = 0,
	string pattern = "",
	// Redis type: enum
	string order = "",
	// Redis type: enum
	string sorting = "",
	// Redis type: key
	string destination = ""
);

/**
 * SPOP
 *
 * Remove and return one or multiple random members from a set
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string SPOP(
	string key,
	// Redis type: integer
	int count = 0
);

/**
 * SRANDMEMBER
 *
 * Get one or multiple random members from a set
 *
 * Time complexity: Without the count argument O(1), otherwise O(N) where N is the absolute
 * value of the passed count.
 * Annotated return value: bulk-string
 */
string SRANDMEMBER(
	string key,
	// Redis type: integer
	int count = 0
);

/**
 * SREM
 *
 * Remove one or more members from a set
 *
 * Time complexity: O(N) where N is the number of members to be removed.
 * Annotated return value: integer
 */
int SREM(
	string key,
	string member
);

/**
 * STRLEN
 *
 * Get the length of the value stored in a key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int STRLEN(
	string key
);

/**
 * SUNION
 *
 * Add multiple sets
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 * Annotated return value: array
 */
int SUNION(
	string key
);

/**
 * SUNIONSTORE
 *
 * Add multiple sets and store the resulting set in a key
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 * Annotated return value: integer
 */
int SUNIONSTORE(
	// Redis type: key
	string destination,
	string key
);

/**
 * SYNC
 *
 * Internal command used for replication
 * Annotated return value: 
 */
string SYNC();

/**
 * TIME
 *
 * Return the current server time
 *
 * Time complexity: O(1)
 * Annotated return value: array
 */
int TIME();

/**
 * TTL
 *
 * Get the time to live for a key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int TTL(
	string key
);

/**
 * TYPE
 *
 * Determine the type stored at key
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string TYPE(
	string key
);

/**
 * UNWATCH
 *
 * Forget about all watched keys
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string UNWATCH();

/**
 * WAIT
 *
 * Wait for the synchronous replication of all the write commands sent in the context of the current connection
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int WAIT(
	// Redis type: integer
	int numslaves,
	// Redis type: integer
	int timeout
);

/**
 * WATCH
 *
 * Watch the given keys to determine execution of the MULTI/EXEC block
 *
 * Time complexity: O(1) for every key.
 * Annotated return value: simple-string
 */
string WATCH(
	string key
);

/**
 * ZADD
 *
 * Add one or more members to a sorted set, or update its score if it already exists
 *
 * Time complexity: O(log(N)) for each item added, where N is the number of elements in the
 * sorted set.

 * - Valid values for condition: "NX", "XX"

 * - Valid values for change: "CH"

 * - Valid values for increment: "INCR"
 * Annotated return value: integer
 */
int ZADD(
	string key,
	// Redis type: enum
	string condition = "",
	// Redis type: enum
	string change = "",
	// Redis type: enum
	string increment = "",
	// Redis type: double
	float score = 0.0,
	string member = ""
);

/**
 * ZCARD
 *
 * Get the number of members in a sorted set
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int ZCARD(
	string key
);

/**
 * ZCOUNT
 *
 * Count the members in a sorted set with scores within the given values
 *
 * Time complexity: O(log(N)) with N being the number of elements in the sorted set.
 * Annotated return value: integer
 */
int ZCOUNT(
	string key,
	// Redis type: double
	float min,
	// Redis type: double
	float max
);

/**
 * ZINCRBY
 *
 * Increment the score of a member in a sorted set
 *
 * Time complexity: O(log(N)) where N is the number of elements in the sorted set.
 * Annotated return value: bulk-string
 */
string ZINCRBY(
	string key,
	// Redis type: integer
	int increment,
	string member
);

/**
 * ZINTERSTORE
 *
 * Intersect multiple sorted sets and store the resulting sorted set in a new key
 *
 * Time complexity: O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K
 * being the number of input sorted sets and M being the number of elements in
 * the resulting sorted set.

 * - Valid values for aggregate: "SUM", "MIN", "MAX"
 * Annotated return value: integer
 */
int ZINTERSTORE(
	// Redis type: key
	string destination,
	// Redis type: integer
	int numkeys,
	string key,
	// Redis type: integer
	int weight = 0,
	// Redis type: enum
	string aggregate = ""
);

/**
 * ZLEXCOUNT
 *
 * Count the number of members in a sorted set between a given lexicographical range
 *
 * Time complexity: O(log(N)) with N being the number of elements in the sorted set.
 * Annotated return value: integer
 */
int ZLEXCOUNT(
	string key,
	string min,
	string max
);

/**
 * ZRANGE
 *
 * Return a range of members in a sorted set, by index
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements returned.

 * - Valid values for withscores: "WITHSCORES"
 * Annotated return value: array
 */
int ZRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop,
	// Redis type: enum
	string withscores = ""
);

/**
 * ZRANGEBYLEX
 *
 * Return a range of members in a sorted set, by lexicographical range
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements being returned. If M is constant (e.g. always asking for
 * the first 10 elements with LIMIT), you can consider it O(log(N)).
 * Annotated return value: array
 */
int ZRANGEBYLEX(
	string key,
	string min,
	string max,
	// Redis type: integer
	int offset = 0,
	// Redis type: integer
	int count = 0
);

/**
 * ZREVRANGEBYLEX
 *
 * Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements being returned. If M is constant (e.g. always asking for
 * the first 10 elements with LIMIT), you can consider it O(log(N)).
 * Annotated return value: array
 */
int ZREVRANGEBYLEX(
	string key,
	string max,
	string min,
	// Redis type: integer
	int offset = 0,
	// Redis type: integer
	int count = 0
);

/**
 * ZRANGEBYSCORE
 *
 * Return a range of members in a sorted set, by score
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements being returned. If M is constant (e.g. always asking for
 * the first 10 elements with LIMIT), you can consider it O(log(N)).

 * - Valid values for withscores: "WITHSCORES"
 * Annotated return value: array
 */
int ZRANGEBYSCORE(
	string key,
	// Redis type: double
	float min,
	// Redis type: double
	float max,
	// Redis type: enum
	string withscores = "",
	// Redis type: integer
	int offset = 0,
	// Redis type: integer
	int count = 0
);

/**
 * ZRANK
 *
 * Determine the index of a member in a sorted set
 *
 * Time complexity: O(log(N))
 * Annotated return value: integer
 */
int ZRANK(
	string key,
	string member
);

/**
 * ZREM
 *
 * Remove one or more members from a sorted set
 *
 * Time complexity: O(M*log(N)) with N being the number of elements in the sorted set and M the
 * number of elements to be removed.
 * Annotated return value: integer
 */
int ZREM(
	string key,
	string member
);

/**
 * ZREMRANGEBYLEX
 *
 * Remove all members in a sorted set between the given lexicographical range
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements removed by the operation.
 * Annotated return value: integer
 */
int ZREMRANGEBYLEX(
	string key,
	string min,
	string max
);

/**
 * ZREMRANGEBYRANK
 *
 * Remove all members in a sorted set within the given indexes
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements removed by the operation.
 * Annotated return value: integer
 */
int ZREMRANGEBYRANK(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop
);

/**
 * ZREMRANGEBYSCORE
 *
 * Remove all members in a sorted set within the given scores
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements removed by the operation.
 * Annotated return value: integer
 */
int ZREMRANGEBYSCORE(
	string key,
	// Redis type: double
	float min,
	// Redis type: double
	float max
);

/**
 * ZREVRANGE
 *
 * Return a range of members in a sorted set, by index, with scores ordered from high to low
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements returned.

 * - Valid values for withscores: "WITHSCORES"
 * Annotated return value: array
 */
int ZREVRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop,
	// Redis type: enum
	string withscores = ""
);

/**
 * ZREVRANGEBYSCORE
 *
 * Return a range of members in a sorted set, by score, with scores ordered from high to low
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements being returned. If M is constant (e.g. always asking for
 * the first 10 elements with LIMIT), you can consider it O(log(N)).

 * - Valid values for withscores: "WITHSCORES"
 * Annotated return value: array
 */
int ZREVRANGEBYSCORE(
	string key,
	// Redis type: double
	float max,
	// Redis type: double
	float min,
	// Redis type: enum
	string withscores = "",
	// Redis type: integer
	int offset = 0,
	// Redis type: integer
	int count = 0
);

/**
 * ZREVRANK
 *
 * Determine the index of a member in a sorted set, with scores ordered from high to low
 *
 * Time complexity: O(log(N))
 * Annotated return value: integer
 */
int ZREVRANK(
	string key,
	string member
);

/**
 * ZSCORE
 *
 * Get the score associated with the given member in a sorted set
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string ZSCORE(
	string key,
	string member
);

/**
 * ZUNIONSTORE
 *
 * Add multiple sorted sets and store the resulting sorted set in a new key
 *
 * Time complexity: O(N)+O(M log(M)) with N being the sum of the sizes of the input sorted sets,
 * and M being the number of elements in the resulting sorted set.

 * - Valid values for aggregate: "SUM", "MIN", "MAX"
 * Annotated return value: integer
 */
int ZUNIONSTORE(
	// Redis type: key
	string destination,
	// Redis type: integer
	int numkeys,
	string key,
	// Redis type: integer
	int weight = 0,
	// Redis type: enum
	string aggregate = ""
);

/**
 * SCAN
 *
 * Incrementally iterate the keys space
 *
 * Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command
 * calls for the cursor to return back to 0. N is the number of elements inside
 * the collection..
 * Annotated return value: 
 */
string SCAN(
	// Redis type: integer
	int cursor,
	string pattern = "",
	// Redis type: integer
	int count = 0
);

/**
 * SSCAN
 *
 * Incrementally iterate Set elements
 *
 * Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command
 * calls for the cursor to return back to 0. N is the number of elements inside
 * the collection..
 * Annotated return value: 
 */
string SSCAN(
	string key,
	// Redis type: integer
	int cursor,
	string pattern = "",
	// Redis type: integer
	int count = 0
);

/**
 * HSCAN
 *
 * Incrementally iterate hash fields and associated values
 *
 * Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command
 * calls for the cursor to return back to 0. N is the number of elements inside
 * the collection..
 * Annotated return value: 
 */
string HSCAN(
	string key,
	// Redis type: integer
	int cursor,
	string pattern = "",
	// Redis type: integer
	int count = 0
);

/**
 * ZSCAN
 *
 * Incrementally iterate sorted sets elements and associated scores
 *
 * Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command
 * calls for the cursor to return back to 0. N is the number of elements inside
 * the collection..
 * Annotated return value: 
 */
string ZSCAN(
	string key,
	// Redis type: integer
	int cursor,
	string pattern = "",
	// Redis type: integer
	int count = 0
);



// Implementation below
int APPEND(
	string key,
	string value
) {
  redisPushBinarySafe("APPEND");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return StringToInt(redisCommand());
}

string AUTH(
	string password
) {
  redisPushBinarySafe("AUTH");
  redisPushBinarySafe(password);
  return redisCommand();
}

string BGREWRITEAOF() {
  redisPushBinarySafe("BGREWRITEAOF");
  return redisCommand();
}

string BGSAVE() {
  redisPushBinarySafe("BGSAVE");
  return redisCommand();
}

int BITCOUNT(
	string key,
	// Redis type: integer
	int start = 0,
	// Redis type: integer
	int end = 0
) {
  redisPushBinarySafe("BITCOUNT");
  redisPushBinarySafe(key);
  if (start != 0) redisPushBinarySafe(IntToString(start));
  if (end != 0) redisPushBinarySafe(IntToString(end));
  return StringToInt(redisCommand());
}

int BITOP(
	string operation,
	// Redis type: key
	string destkey,
	string key
) {
  redisPushBinarySafe("BITOP");
  redisPushBinarySafe(operation);
  redisPushBinarySafe(destkey);
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int BITPOS(
	string key,
	// Redis type: integer
	int bit,
	// Redis type: integer
	int start = 0,
	// Redis type: integer
	int end = 0
) {
  redisPushBinarySafe("BITPOS");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(bit));
  if (start != 0) redisPushBinarySafe(IntToString(start));
  if (end != 0) redisPushBinarySafe(IntToString(end));
  return StringToInt(redisCommand());
}

int BLPOP(
	string key,
	// Redis type: integer
	int timeout
) {
  redisPushBinarySafe("BLPOP");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(timeout));
  return StringToInt(redisCommand());
}

int BRPOP(
	string key,
	// Redis type: integer
	int timeout
) {
  redisPushBinarySafe("BRPOP");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(timeout));
  return StringToInt(redisCommand());
}

string BRPOPLPUSH(
	// Redis type: key
	string source,
	// Redis type: key
	string destination,
	// Redis type: integer
	int timeout
) {
  redisPushBinarySafe("BRPOPLPUSH");
  redisPushBinarySafe(source);
  redisPushBinarySafe(destination);
  redisPushBinarySafe(IntToString(timeout));
  return redisCommand();
}

string CLIENT_KILL(
	string ip_port = "",
	// Redis type: integer
	int client_id = 0,
	Skipping sub-command: CLIENT KILL/{"command"=>"TYPE", "type"=>"enum", "enum"=>["normal", "slave", "pubsub"], "optional"=>true} - not supported yet.  = "",
	string ip_port = "",
	string yes_no = ""
) {
  redisPushBinarySafe("CLIENT KILL");
  if (ip_port != "") redisPushBinarySafe(ip_port);
  if (client_id != 0) redisPushBinarySafe(IntToString(client_id));
  redisPushBinarySafe();
  if (ip_port != "") redisPushBinarySafe(ip_port);
  if (yes_no != "") redisPushBinarySafe(yes_no);
  return redisCommand();
}

string CLIENT_LIST() {
  redisPushBinarySafe("CLIENT LIST");
  return redisCommand();
}

string CLIENT_GETNAME() {
  redisPushBinarySafe("CLIENT GETNAME");
  return redisCommand();
}

string CLIENT_PAUSE(
	// Redis type: integer
	int timeout
) {
  redisPushBinarySafe("CLIENT PAUSE");
  redisPushBinarySafe(IntToString(timeout));
  return redisCommand();
}

string CLIENT_SETNAME(
	string connection_name
) {
  redisPushBinarySafe("CLIENT SETNAME");
  redisPushBinarySafe(connection_name);
  return redisCommand();
}

string CLUSTER_ADDSLOTS(
	// Redis type: integer
	int slot
) {
  redisPushBinarySafe("CLUSTER ADDSLOTS");
  redisPushBinarySafe(IntToString(slot));
  return redisCommand();
}

string CLUSTER_COUNT_FAILURE_REPORTS(
	string node_id
) {
  redisPushBinarySafe("CLUSTER COUNT_FAILURE_REPORTS");
  redisPushBinarySafe(node_id);
  return redisCommand();
}

int CLUSTER_COUNTKEYSINSLOT(
	// Redis type: integer
	int slot
) {
  redisPushBinarySafe("CLUSTER COUNTKEYSINSLOT");
  redisPushBinarySafe(IntToString(slot));
  return StringToInt(redisCommand());
}

string CLUSTER_DELSLOTS(
	// Redis type: integer
	int slot
) {
  redisPushBinarySafe("CLUSTER DELSLOTS");
  redisPushBinarySafe(IntToString(slot));
  return redisCommand();
}

string CLUSTER_FAILOVER(
	// Redis type: enum
	string options = ""
) {
  redisPushBinarySafe("CLUSTER FAILOVER");
  if (options != "") redisPushBinarySafe(options);
  return redisCommand();
}

string CLUSTER_FORGET(
	string node_id
) {
  redisPushBinarySafe("CLUSTER FORGET");
  redisPushBinarySafe(node_id);
  return redisCommand();
}

int CLUSTER_GETKEYSINSLOT(
	// Redis type: integer
	int slot,
	// Redis type: integer
	int count
) {
  redisPushBinarySafe("CLUSTER GETKEYSINSLOT");
  redisPushBinarySafe(IntToString(slot));
  redisPushBinarySafe(IntToString(count));
  return StringToInt(redisCommand());
}

string CLUSTER_INFO() {
  redisPushBinarySafe("CLUSTER INFO");
  return redisCommand();
}

int CLUSTER_KEYSLOT(
	string key
) {
  redisPushBinarySafe("CLUSTER KEYSLOT");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

string CLUSTER_MEET(
	string ip,
	// Redis type: integer
	int port
) {
  redisPushBinarySafe("CLUSTER MEET");
  redisPushBinarySafe(ip);
  redisPushBinarySafe(IntToString(port));
  return redisCommand();
}

string CLUSTER_NODES() {
  redisPushBinarySafe("CLUSTER NODES");
  return redisCommand();
}

string CLUSTER_REPLICATE(
	string node_id
) {
  redisPushBinarySafe("CLUSTER REPLICATE");
  redisPushBinarySafe(node_id);
  return redisCommand();
}

string CLUSTER_RESET(
	// Redis type: enum
	string reset_type = ""
) {
  redisPushBinarySafe("CLUSTER RESET");
  if (reset_type != "") redisPushBinarySafe(reset_type);
  return redisCommand();
}

string CLUSTER_SAVECONFIG() {
  redisPushBinarySafe("CLUSTER SAVECONFIG");
  return redisCommand();
}

string CLUSTER_SET_CONFIG_EPOCH(
	// Redis type: integer
	int config_epoch
) {
  redisPushBinarySafe("CLUSTER SET_CONFIG_EPOCH");
  redisPushBinarySafe(IntToString(config_epoch));
  return redisCommand();
}

string CLUSTER_SETSLOT(
	// Redis type: integer
	int slot,
	// Redis type: enum
	string subcommand,
	string node_id = ""
) {
  redisPushBinarySafe("CLUSTER SETSLOT");
  redisPushBinarySafe(IntToString(slot));
  redisPushBinarySafe(subcommand);
  if (node_id != "") redisPushBinarySafe(node_id);
  return redisCommand();
}

string CLUSTER_SLAVES(
	string node_id
) {
  redisPushBinarySafe("CLUSTER SLAVES");
  redisPushBinarySafe(node_id);
  return redisCommand();
}

int CLUSTER_SLOTS() {
  redisPushBinarySafe("CLUSTER SLOTS");
  return StringToInt(redisCommand());
}

int COMMAND() {
  redisPushBinarySafe("COMMAND");
  return StringToInt(redisCommand());
}

int COMMAND_COUNT() {
  redisPushBinarySafe("COMMAND COUNT");
  return StringToInt(redisCommand());
}

int COMMAND_GETKEYS() {
  redisPushBinarySafe("COMMAND GETKEYS");
  return StringToInt(redisCommand());
}

int COMMAND_INFO(
	string command_name
) {
  redisPushBinarySafe("COMMAND INFO");
  redisPushBinarySafe(command_name);
  return StringToInt(redisCommand());
}

int CONFIG_GET(
	string parameter
) {
  redisPushBinarySafe("CONFIG GET");
  redisPushBinarySafe(parameter);
  return StringToInt(redisCommand());
}

string CONFIG_REWRITE() {
  redisPushBinarySafe("CONFIG REWRITE");
  return redisCommand();
}

string CONFIG_SET(
	string parameter,
	string value
) {
  redisPushBinarySafe("CONFIG SET");
  redisPushBinarySafe(parameter);
  redisPushBinarySafe(value);
  return redisCommand();
}

string CONFIG_RESETSTAT() {
  redisPushBinarySafe("CONFIG RESETSTAT");
  return redisCommand();
}

int DBSIZE() {
  redisPushBinarySafe("DBSIZE");
  return StringToInt(redisCommand());
}

string DEBUG_OBJECT(
	string key
) {
  redisPushBinarySafe("DEBUG OBJECT");
  redisPushBinarySafe(key);
  return redisCommand();
}

string DEBUG_SEGFAULT() {
  redisPushBinarySafe("DEBUG SEGFAULT");
  return redisCommand();
}

int DECR(
	string key
) {
  redisPushBinarySafe("DECR");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int DECRBY(
	string key,
	// Redis type: integer
	int decrement
) {
  redisPushBinarySafe("DECRBY");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(decrement));
  return StringToInt(redisCommand());
}

int DEL(
	string key
) {
  redisPushBinarySafe("DEL");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

string DISCARD() {
  redisPushBinarySafe("DISCARD");
  return redisCommand();
}

string DUMP(
	string key
) {
  redisPushBinarySafe("DUMP");
  redisPushBinarySafe(key);
  return redisCommand();
}

string ECHO(
	string message
) {
  redisPushBinarySafe("ECHO");
  redisPushBinarySafe(message);
  return redisCommand();
}

string EVAL(
	string script,
	// Redis type: integer
	int numkeys,
	string key,
	string arg
) {
  redisPushBinarySafe("EVAL");
  redisPushBinarySafe(script);
  redisPushBinarySafe(IntToString(numkeys));
  redisPushBinarySafe(key);
  redisPushBinarySafe(arg);
  return redisCommand();
}

string EVALSHA(
	string sha1,
	// Redis type: integer
	int numkeys,
	string key,
	string arg
) {
  redisPushBinarySafe("EVALSHA");
  redisPushBinarySafe(sha1);
  redisPushBinarySafe(IntToString(numkeys));
  redisPushBinarySafe(key);
  redisPushBinarySafe(arg);
  return redisCommand();
}

int EXEC() {
  redisPushBinarySafe("EXEC");
  return StringToInt(redisCommand());
}

int EXISTS(
	string key
) {
  redisPushBinarySafe("EXISTS");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int EXPIRE(
	string key,
	// Redis type: integer
	int seconds
) {
  redisPushBinarySafe("EXPIRE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(seconds));
  return StringToInt(redisCommand());
}

int EXPIREAT(
	string key,
	// Redis type: posix time
	string timestamp
) {
  redisPushBinarySafe("EXPIREAT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(timestamp);
  return StringToInt(redisCommand());
}

string FLUSHALL() {
  redisPushBinarySafe("FLUSHALL");
  return redisCommand();
}

string FLUSHDB() {
  redisPushBinarySafe("FLUSHDB");
  return redisCommand();
}

int GEOADD(
	string key,
	// Redis type: double
	float longitude,
	// Redis type: double
	float latitude,
	string member
) {
  redisPushBinarySafe("GEOADD");
  redisPushBinarySafe(key);
  redisPushBinarySafe(FloatToString(longitude, 0));
  redisPushBinarySafe(FloatToString(latitude, 0));
  redisPushBinarySafe(member);
  return StringToInt(redisCommand());
}

int GEOHASH(
	string key,
	string member
) {
  redisPushBinarySafe("GEOHASH");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return StringToInt(redisCommand());
}

int GEOPOS(
	string key,
	string member
) {
  redisPushBinarySafe("GEOPOS");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return StringToInt(redisCommand());
}

string GEODIST(
	string key,
	string member1,
	string member2,
	string unit = ""
) {
  redisPushBinarySafe("GEODIST");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member1);
  redisPushBinarySafe(member2);
  if (unit != "") redisPushBinarySafe(unit);
  return redisCommand();
}

int GEORADIUS(
	string key,
	// Redis type: double
	float longitude,
	// Redis type: double
	float latitude,
	// Redis type: double
	float radius,
	// Redis type: enum
	string unit,
	// Redis type: enum
	string withcoord = "",
	// Redis type: enum
	string withdist = "",
	// Redis type: enum
	string withhash = ""
) {
  redisPushBinarySafe("GEORADIUS");
  redisPushBinarySafe(key);
  redisPushBinarySafe(FloatToString(longitude, 0));
  redisPushBinarySafe(FloatToString(latitude, 0));
  redisPushBinarySafe(FloatToString(radius, 0));
  redisPushBinarySafe(unit);
  if (withcoord != "") redisPushBinarySafe(withcoord);
  if (withdist != "") redisPushBinarySafe(withdist);
  if (withhash != "") redisPushBinarySafe(withhash);
  return StringToInt(redisCommand());
}

string GEORADIUSBYMEMBER(
	string key,
	string member,
	// Redis type: double
	float radius,
	// Redis type: enum
	string unit,
	// Redis type: enum
	string withcoord = "",
	// Redis type: enum
	string withdist = "",
	// Redis type: enum
	string withhash = ""
) {
  redisPushBinarySafe("GEORADIUSBYMEMBER");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  redisPushBinarySafe(FloatToString(radius, 0));
  redisPushBinarySafe(unit);
  if (withcoord != "") redisPushBinarySafe(withcoord);
  if (withdist != "") redisPushBinarySafe(withdist);
  if (withhash != "") redisPushBinarySafe(withhash);
  return redisCommand();
}

string GET(
	string key
) {
  redisPushBinarySafe("GET");
  redisPushBinarySafe(key);
  return redisCommand();
}

int GETBIT(
	string key,
	// Redis type: integer
	int offset
) {
  redisPushBinarySafe("GETBIT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(offset));
  return StringToInt(redisCommand());
}

string GETRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int end
) {
  redisPushBinarySafe("GETRANGE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(start));
  redisPushBinarySafe(IntToString(end));
  return redisCommand();
}

string GETSET(
	string key,
	string value
) {
  redisPushBinarySafe("GETSET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return redisCommand();
}

int HDEL(
	string key,
	string field
) {
  redisPushBinarySafe("HDEL");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  return StringToInt(redisCommand());
}

int HEXISTS(
	string key,
	string field
) {
  redisPushBinarySafe("HEXISTS");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  return StringToInt(redisCommand());
}

string HGET(
	string key,
	string field
) {
  redisPushBinarySafe("HGET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  return redisCommand();
}

int HGETALL(
	string key
) {
  redisPushBinarySafe("HGETALL");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int HINCRBY(
	string key,
	string field,
	// Redis type: integer
	int increment
) {
  redisPushBinarySafe("HINCRBY");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  redisPushBinarySafe(IntToString(increment));
  return StringToInt(redisCommand());
}

string HINCRBYFLOAT(
	string key,
	string field,
	// Redis type: double
	float increment
) {
  redisPushBinarySafe("HINCRBYFLOAT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  redisPushBinarySafe(FloatToString(increment, 0));
  return redisCommand();
}

int HKEYS(
	string key
) {
  redisPushBinarySafe("HKEYS");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int HLEN(
	string key
) {
  redisPushBinarySafe("HLEN");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int HMGET(
	string key,
	string field
) {
  redisPushBinarySafe("HMGET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  return StringToInt(redisCommand());
}

string HMSET(
	string key,
	string field,
	string value
) {
  redisPushBinarySafe("HMSET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  redisPushBinarySafe(value);
  return redisCommand();
}

int HSET(
	string key,
	string field,
	string value
) {
  redisPushBinarySafe("HSET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  redisPushBinarySafe(value);
  return StringToInt(redisCommand());
}

int HSETNX(
	string key,
	string field,
	string value
) {
  redisPushBinarySafe("HSETNX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  redisPushBinarySafe(value);
  return StringToInt(redisCommand());
}

int HSTRLEN(
	string key,
	string field
) {
  redisPushBinarySafe("HSTRLEN");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  return StringToInt(redisCommand());
}

int HVALS(
	string key
) {
  redisPushBinarySafe("HVALS");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int INCR(
	string key
) {
  redisPushBinarySafe("INCR");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int INCRBY(
	string key,
	// Redis type: integer
	int increment
) {
  redisPushBinarySafe("INCRBY");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(increment));
  return StringToInt(redisCommand());
}

string INCRBYFLOAT(
	string key,
	// Redis type: double
	float increment
) {
  redisPushBinarySafe("INCRBYFLOAT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(FloatToString(increment, 0));
  return redisCommand();
}

string INFO(
	string section = ""
) {
  redisPushBinarySafe("INFO");
  if (section != "") redisPushBinarySafe(section);
  return redisCommand();
}

int KEYS(
	string pattern
) {
  redisPushBinarySafe("KEYS");
  redisPushBinarySafe(pattern);
  return StringToInt(redisCommand());
}

int LASTSAVE() {
  redisPushBinarySafe("LASTSAVE");
  return StringToInt(redisCommand());
}

string LINDEX(
	string key,
	// Redis type: integer
	int index
) {
  redisPushBinarySafe("LINDEX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(index));
  return redisCommand();
}

int LINSERT(
	string key,
	// Redis type: enum
	string where,
	string pivot,
	string value
) {
  redisPushBinarySafe("LINSERT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(where);
  redisPushBinarySafe(pivot);
  redisPushBinarySafe(value);
  return StringToInt(redisCommand());
}

int LLEN(
	string key
) {
  redisPushBinarySafe("LLEN");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

string LPOP(
	string key
) {
  redisPushBinarySafe("LPOP");
  redisPushBinarySafe(key);
  return redisCommand();
}

int LPUSH(
	string key,
	string value
) {
  redisPushBinarySafe("LPUSH");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return StringToInt(redisCommand());
}

int LPUSHX(
	string key,
	string value
) {
  redisPushBinarySafe("LPUSHX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return StringToInt(redisCommand());
}

int LRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop
) {
  redisPushBinarySafe("LRANGE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(start));
  redisPushBinarySafe(IntToString(stop));
  return StringToInt(redisCommand());
}

int LREM(
	string key,
	// Redis type: integer
	int count,
	string value
) {
  redisPushBinarySafe("LREM");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(count));
  redisPushBinarySafe(value);
  return StringToInt(redisCommand());
}

string LSET(
	string key,
	// Redis type: integer
	int index,
	string value
) {
  redisPushBinarySafe("LSET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(index));
  redisPushBinarySafe(value);
  return redisCommand();
}

string LTRIM(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop
) {
  redisPushBinarySafe("LTRIM");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(start));
  redisPushBinarySafe(IntToString(stop));
  return redisCommand();
}

int MGET(
	string key
) {
  redisPushBinarySafe("MGET");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

string MIGRATE(
	string host,
	string port,
	string key,
	// Redis type: integer
	int destination_db,
	// Redis type: integer
	int timeout,
	// Redis type: enum
	string copy = "",
	// Redis type: enum
	string replace = ""
) {
  redisPushBinarySafe("MIGRATE");
  redisPushBinarySafe(host);
  redisPushBinarySafe(port);
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(destination_db));
  redisPushBinarySafe(IntToString(timeout));
  if (copy != "") redisPushBinarySafe(copy);
  if (replace != "") redisPushBinarySafe(replace);
  return redisCommand();
}

string MONITOR() {
  redisPushBinarySafe("MONITOR");
  return redisCommand();
}

int MOVE(
	string key,
	// Redis type: integer
	int db
) {
  redisPushBinarySafe("MOVE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(db));
  return StringToInt(redisCommand());
}

string MSET(
	string key,
	string value
) {
  redisPushBinarySafe("MSET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return redisCommand();
}

int MSETNX(
	string key,
	string value
) {
  redisPushBinarySafe("MSETNX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return StringToInt(redisCommand());
}

string MULTI() {
  redisPushBinarySafe("MULTI");
  return redisCommand();
}

string OBJECT(
	string subcommand,
	string arguments = ""
) {
  redisPushBinarySafe("OBJECT");
  redisPushBinarySafe(subcommand);
  if (arguments != "") redisPushBinarySafe(arguments);
  return redisCommand();
}

int PERSIST(
	string key
) {
  redisPushBinarySafe("PERSIST");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int PEXPIRE(
	string key,
	// Redis type: integer
	int milliseconds
) {
  redisPushBinarySafe("PEXPIRE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(milliseconds));
  return StringToInt(redisCommand());
}

int PEXPIREAT(
	string key,
	// Redis type: posix time
	string milliseconds_timestamp
) {
  redisPushBinarySafe("PEXPIREAT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(milliseconds_timestamp);
  return StringToInt(redisCommand());
}

int PFADD(
	string key,
	string element
) {
  redisPushBinarySafe("PFADD");
  redisPushBinarySafe(key);
  redisPushBinarySafe(element);
  return StringToInt(redisCommand());
}

int PFCOUNT(
	string key
) {
  redisPushBinarySafe("PFCOUNT");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

string PFMERGE(
	// Redis type: key
	string destkey,
	// Redis type: key
	string sourcekey
) {
  redisPushBinarySafe("PFMERGE");
  redisPushBinarySafe(destkey);
  redisPushBinarySafe(sourcekey);
  return redisCommand();
}

string PING() {
  redisPushBinarySafe("PING");
  return redisCommand();
}

string PSETEX(
	string key,
	// Redis type: integer
	int milliseconds,
	string value
) {
  redisPushBinarySafe("PSETEX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(milliseconds));
  redisPushBinarySafe(value);
  return redisCommand();
}

int PUBSUB(
	string subcommand,
	string argument = ""
) {
  redisPushBinarySafe("PUBSUB");
  redisPushBinarySafe(subcommand);
  if (argument != "") redisPushBinarySafe(argument);
  return StringToInt(redisCommand());
}

int PTTL(
	string key
) {
  redisPushBinarySafe("PTTL");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int PUBLISH(
	string channel,
	string message
) {
  redisPushBinarySafe("PUBLISH");
  redisPushBinarySafe(channel);
  redisPushBinarySafe(message);
  return StringToInt(redisCommand());
}

string QUIT() {
  redisPushBinarySafe("QUIT");
  return redisCommand();
}

string RANDOMKEY() {
  redisPushBinarySafe("RANDOMKEY");
  return redisCommand();
}

string RENAME(
	string key,
	// Redis type: key
	string newkey
) {
  redisPushBinarySafe("RENAME");
  redisPushBinarySafe(key);
  redisPushBinarySafe(newkey);
  return redisCommand();
}

int RENAMENX(
	string key,
	// Redis type: key
	string newkey
) {
  redisPushBinarySafe("RENAMENX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(newkey);
  return StringToInt(redisCommand());
}

string RESTORE(
	string key,
	// Redis type: integer
	int ttl,
	string serialized_value,
	// Redis type: enum
	string replace = ""
) {
  redisPushBinarySafe("RESTORE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(ttl));
  redisPushBinarySafe(serialized_value);
  if (replace != "") redisPushBinarySafe(replace);
  return redisCommand();
}

int ROLE() {
  redisPushBinarySafe("ROLE");
  return StringToInt(redisCommand());
}

string RPOP(
	string key
) {
  redisPushBinarySafe("RPOP");
  redisPushBinarySafe(key);
  return redisCommand();
}

string RPOPLPUSH(
	// Redis type: key
	string source,
	// Redis type: key
	string destination
) {
  redisPushBinarySafe("RPOPLPUSH");
  redisPushBinarySafe(source);
  redisPushBinarySafe(destination);
  return redisCommand();
}

int RPUSH(
	string key,
	string value
) {
  redisPushBinarySafe("RPUSH");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return StringToInt(redisCommand());
}

int RPUSHX(
	string key,
	string value
) {
  redisPushBinarySafe("RPUSHX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return StringToInt(redisCommand());
}

int SADD(
	string key,
	string member
) {
  redisPushBinarySafe("SADD");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return StringToInt(redisCommand());
}

string SAVE() {
  redisPushBinarySafe("SAVE");
  return redisCommand();
}

int SCARD(
	string key
) {
  redisPushBinarySafe("SCARD");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int SCRIPT_EXISTS(
	string script
) {
  redisPushBinarySafe("SCRIPT EXISTS");
  redisPushBinarySafe(script);
  return StringToInt(redisCommand());
}

string SCRIPT_FLUSH() {
  redisPushBinarySafe("SCRIPT FLUSH");
  return redisCommand();
}

string SCRIPT_KILL() {
  redisPushBinarySafe("SCRIPT KILL");
  return redisCommand();
}

string SCRIPT_LOAD(
	string script
) {
  redisPushBinarySafe("SCRIPT LOAD");
  redisPushBinarySafe(script);
  return redisCommand();
}

int SDIFF(
	string key
) {
  redisPushBinarySafe("SDIFF");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int SDIFFSTORE(
	// Redis type: key
	string destination,
	string key
) {
  redisPushBinarySafe("SDIFFSTORE");
  redisPushBinarySafe(destination);
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

string SELECT(
	// Redis type: integer
	int index
) {
  redisPushBinarySafe("SELECT");
  redisPushBinarySafe(IntToString(index));
  return redisCommand();
}

string SET(
	string key,
	string value,
	// Redis type: integer
	int seconds = 0,
	// Redis type: integer
	int milliseconds = 0,
	// Redis type: enum
	string condition = ""
) {
  redisPushBinarySafe("SET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  if (seconds != 0) redisPushBinarySafe(IntToString(seconds));
  if (milliseconds != 0) redisPushBinarySafe(IntToString(milliseconds));
  if (condition != "") redisPushBinarySafe(condition);
  return redisCommand();
}

int SETBIT(
	string key,
	// Redis type: integer
	int offset,
	string value
) {
  redisPushBinarySafe("SETBIT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(offset));
  redisPushBinarySafe(value);
  return StringToInt(redisCommand());
}

string SETEX(
	string key,
	// Redis type: integer
	int seconds,
	string value
) {
  redisPushBinarySafe("SETEX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(seconds));
  redisPushBinarySafe(value);
  return redisCommand();
}

int SETNX(
	string key,
	string value
) {
  redisPushBinarySafe("SETNX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return StringToInt(redisCommand());
}

int SETRANGE(
	string key,
	// Redis type: integer
	int offset,
	string value
) {
  redisPushBinarySafe("SETRANGE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(offset));
  redisPushBinarySafe(value);
  return StringToInt(redisCommand());
}

string SHUTDOWN(
	// Redis type: enum
	string NOSAVE = "",
	// Redis type: enum
	string SAVE = ""
) {
  redisPushBinarySafe("SHUTDOWN");
  if (NOSAVE != "") redisPushBinarySafe(NOSAVE);
  if (SAVE != "") redisPushBinarySafe(SAVE);
  return redisCommand();
}

int SINTER(
	string key
) {
  redisPushBinarySafe("SINTER");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int SINTERSTORE(
	// Redis type: key
	string destination,
	string key
) {
  redisPushBinarySafe("SINTERSTORE");
  redisPushBinarySafe(destination);
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int SISMEMBER(
	string key,
	string member
) {
  redisPushBinarySafe("SISMEMBER");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return StringToInt(redisCommand());
}

string SLAVEOF(
	string host,
	string port
) {
  redisPushBinarySafe("SLAVEOF");
  redisPushBinarySafe(host);
  redisPushBinarySafe(port);
  return redisCommand();
}

string SLOWLOG(
	string subcommand,
	string argument = ""
) {
  redisPushBinarySafe("SLOWLOG");
  redisPushBinarySafe(subcommand);
  if (argument != "") redisPushBinarySafe(argument);
  return redisCommand();
}

int SMEMBERS(
	string key
) {
  redisPushBinarySafe("SMEMBERS");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int SMOVE(
	// Redis type: key
	string source,
	// Redis type: key
	string destination,
	string member
) {
  redisPushBinarySafe("SMOVE");
  redisPushBinarySafe(source);
  redisPushBinarySafe(destination);
  redisPushBinarySafe(member);
  return StringToInt(redisCommand());
}

int SORT(
	string key,
	string pattern = "",
	// Redis type: integer
	int offset = 0,
	// Redis type: integer
	int count = 0,
	string pattern = "",
	// Redis type: enum
	string order = "",
	// Redis type: enum
	string sorting = "",
	// Redis type: key
	string destination = ""
) {
  redisPushBinarySafe("SORT");
  redisPushBinarySafe(key);
  if (pattern != "") redisPushBinarySafe(pattern);
  if (offset != 0) redisPushBinarySafe(IntToString(offset));
  if (count != 0) redisPushBinarySafe(IntToString(count));
  if (pattern != "") redisPushBinarySafe(pattern);
  if (order != "") redisPushBinarySafe(order);
  if (sorting != "") redisPushBinarySafe(sorting);
  if (destination != "") redisPushBinarySafe(destination);
  return StringToInt(redisCommand());
}

string SPOP(
	string key,
	// Redis type: integer
	int count = 0
) {
  redisPushBinarySafe("SPOP");
  redisPushBinarySafe(key);
  if (count != 0) redisPushBinarySafe(IntToString(count));
  return redisCommand();
}

string SRANDMEMBER(
	string key,
	// Redis type: integer
	int count = 0
) {
  redisPushBinarySafe("SRANDMEMBER");
  redisPushBinarySafe(key);
  if (count != 0) redisPushBinarySafe(IntToString(count));
  return redisCommand();
}

int SREM(
	string key,
	string member
) {
  redisPushBinarySafe("SREM");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return StringToInt(redisCommand());
}

int STRLEN(
	string key
) {
  redisPushBinarySafe("STRLEN");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int SUNION(
	string key
) {
  redisPushBinarySafe("SUNION");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int SUNIONSTORE(
	// Redis type: key
	string destination,
	string key
) {
  redisPushBinarySafe("SUNIONSTORE");
  redisPushBinarySafe(destination);
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

string SYNC() {
  redisPushBinarySafe("SYNC");
  return redisCommand();
}

int TIME() {
  redisPushBinarySafe("TIME");
  return StringToInt(redisCommand());
}

int TTL(
	string key
) {
  redisPushBinarySafe("TTL");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

string TYPE(
	string key
) {
  redisPushBinarySafe("TYPE");
  redisPushBinarySafe(key);
  return redisCommand();
}

string UNWATCH() {
  redisPushBinarySafe("UNWATCH");
  return redisCommand();
}

int WAIT(
	// Redis type: integer
	int numslaves,
	// Redis type: integer
	int timeout
) {
  redisPushBinarySafe("WAIT");
  redisPushBinarySafe(IntToString(numslaves));
  redisPushBinarySafe(IntToString(timeout));
  return StringToInt(redisCommand());
}

string WATCH(
	string key
) {
  redisPushBinarySafe("WATCH");
  redisPushBinarySafe(key);
  return redisCommand();
}

int ZADD(
	string key,
	// Redis type: enum
	string condition = "",
	// Redis type: enum
	string change = "",
	// Redis type: enum
	string increment = "",
	// Redis type: double
	float score = 0.0,
	string member = ""
) {
  redisPushBinarySafe("ZADD");
  redisPushBinarySafe(key);
  if (condition != "") redisPushBinarySafe(condition);
  if (change != "") redisPushBinarySafe(change);
  if (increment != "") redisPushBinarySafe(increment);
  redisPushBinarySafe(FloatToString(score, 0));
  redisPushBinarySafe(member);
  return StringToInt(redisCommand());
}

int ZCARD(
	string key
) {
  redisPushBinarySafe("ZCARD");
  redisPushBinarySafe(key);
  return StringToInt(redisCommand());
}

int ZCOUNT(
	string key,
	// Redis type: double
	float min,
	// Redis type: double
	float max
) {
  redisPushBinarySafe("ZCOUNT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(FloatToString(min, 0));
  redisPushBinarySafe(FloatToString(max, 0));
  return StringToInt(redisCommand());
}

string ZINCRBY(
	string key,
	// Redis type: integer
	int increment,
	string member
) {
  redisPushBinarySafe("ZINCRBY");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(increment));
  redisPushBinarySafe(member);
  return redisCommand();
}

int ZINTERSTORE(
	// Redis type: key
	string destination,
	// Redis type: integer
	int numkeys,
	string key,
	// Redis type: integer
	int weight = 0,
	// Redis type: enum
	string aggregate = ""
) {
  redisPushBinarySafe("ZINTERSTORE");
  redisPushBinarySafe(destination);
  redisPushBinarySafe(IntToString(numkeys));
  redisPushBinarySafe(key);
  if (weight != 0) redisPushBinarySafe(IntToString(weight));
  if (aggregate != "") redisPushBinarySafe(aggregate);
  return StringToInt(redisCommand());
}

int ZLEXCOUNT(
	string key,
	string min,
	string max
) {
  redisPushBinarySafe("ZLEXCOUNT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(min);
  redisPushBinarySafe(max);
  return StringToInt(redisCommand());
}

int ZRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop,
	// Redis type: enum
	string withscores = ""
) {
  redisPushBinarySafe("ZRANGE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(start));
  redisPushBinarySafe(IntToString(stop));
  if (withscores != "") redisPushBinarySafe(withscores);
  return StringToInt(redisCommand());
}

int ZRANGEBYLEX(
	string key,
	string min,
	string max,
	// Redis type: integer
	int offset = 0,
	// Redis type: integer
	int count = 0
) {
  redisPushBinarySafe("ZRANGEBYLEX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(min);
  redisPushBinarySafe(max);
  if (offset != 0) redisPushBinarySafe(IntToString(offset));
  if (count != 0) redisPushBinarySafe(IntToString(count));
  return StringToInt(redisCommand());
}

int ZREVRANGEBYLEX(
	string key,
	string max,
	string min,
	// Redis type: integer
	int offset = 0,
	// Redis type: integer
	int count = 0
) {
  redisPushBinarySafe("ZREVRANGEBYLEX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(max);
  redisPushBinarySafe(min);
  if (offset != 0) redisPushBinarySafe(IntToString(offset));
  if (count != 0) redisPushBinarySafe(IntToString(count));
  return StringToInt(redisCommand());
}

int ZRANGEBYSCORE(
	string key,
	// Redis type: double
	float min,
	// Redis type: double
	float max,
	// Redis type: enum
	string withscores = "",
	// Redis type: integer
	int offset = 0,
	// Redis type: integer
	int count = 0
) {
  redisPushBinarySafe("ZRANGEBYSCORE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(FloatToString(min, 0));
  redisPushBinarySafe(FloatToString(max, 0));
  if (withscores != "") redisPushBinarySafe(withscores);
  if (offset != 0) redisPushBinarySafe(IntToString(offset));
  if (count != 0) redisPushBinarySafe(IntToString(count));
  return StringToInt(redisCommand());
}

int ZRANK(
	string key,
	string member
) {
  redisPushBinarySafe("ZRANK");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return StringToInt(redisCommand());
}

int ZREM(
	string key,
	string member
) {
  redisPushBinarySafe("ZREM");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return StringToInt(redisCommand());
}

int ZREMRANGEBYLEX(
	string key,
	string min,
	string max
) {
  redisPushBinarySafe("ZREMRANGEBYLEX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(min);
  redisPushBinarySafe(max);
  return StringToInt(redisCommand());
}

int ZREMRANGEBYRANK(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop
) {
  redisPushBinarySafe("ZREMRANGEBYRANK");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(start));
  redisPushBinarySafe(IntToString(stop));
  return StringToInt(redisCommand());
}

int ZREMRANGEBYSCORE(
	string key,
	// Redis type: double
	float min,
	// Redis type: double
	float max
) {
  redisPushBinarySafe("ZREMRANGEBYSCORE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(FloatToString(min, 0));
  redisPushBinarySafe(FloatToString(max, 0));
  return StringToInt(redisCommand());
}

int ZREVRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop,
	// Redis type: enum
	string withscores = ""
) {
  redisPushBinarySafe("ZREVRANGE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(start));
  redisPushBinarySafe(IntToString(stop));
  if (withscores != "") redisPushBinarySafe(withscores);
  return StringToInt(redisCommand());
}

int ZREVRANGEBYSCORE(
	string key,
	// Redis type: double
	float max,
	// Redis type: double
	float min,
	// Redis type: enum
	string withscores = "",
	// Redis type: integer
	int offset = 0,
	// Redis type: integer
	int count = 0
) {
  redisPushBinarySafe("ZREVRANGEBYSCORE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(FloatToString(max, 0));
  redisPushBinarySafe(FloatToString(min, 0));
  if (withscores != "") redisPushBinarySafe(withscores);
  if (offset != 0) redisPushBinarySafe(IntToString(offset));
  if (count != 0) redisPushBinarySafe(IntToString(count));
  return StringToInt(redisCommand());
}

int ZREVRANK(
	string key,
	string member
) {
  redisPushBinarySafe("ZREVRANK");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return StringToInt(redisCommand());
}

string ZSCORE(
	string key,
	string member
) {
  redisPushBinarySafe("ZSCORE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return redisCommand();
}

int ZUNIONSTORE(
	// Redis type: key
	string destination,
	// Redis type: integer
	int numkeys,
	string key,
	// Redis type: integer
	int weight = 0,
	// Redis type: enum
	string aggregate = ""
) {
  redisPushBinarySafe("ZUNIONSTORE");
  redisPushBinarySafe(destination);
  redisPushBinarySafe(IntToString(numkeys));
  redisPushBinarySafe(key);
  if (weight != 0) redisPushBinarySafe(IntToString(weight));
  if (aggregate != "") redisPushBinarySafe(aggregate);
  return StringToInt(redisCommand());
}

string SCAN(
	// Redis type: integer
	int cursor,
	string pattern = "",
	// Redis type: integer
	int count = 0
) {
  redisPushBinarySafe("SCAN");
  redisPushBinarySafe(IntToString(cursor));
  if (pattern != "") redisPushBinarySafe(pattern);
  if (count != 0) redisPushBinarySafe(IntToString(count));
  return redisCommand();
}

string SSCAN(
	string key,
	// Redis type: integer
	int cursor,
	string pattern = "",
	// Redis type: integer
	int count = 0
) {
  redisPushBinarySafe("SSCAN");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(cursor));
  if (pattern != "") redisPushBinarySafe(pattern);
  if (count != 0) redisPushBinarySafe(IntToString(count));
  return redisCommand();
}

string HSCAN(
	string key,
	// Redis type: integer
	int cursor,
	string pattern = "",
	// Redis type: integer
	int count = 0
) {
  redisPushBinarySafe("HSCAN");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(cursor));
  if (pattern != "") redisPushBinarySafe(pattern);
  if (count != 0) redisPushBinarySafe(IntToString(count));
  return redisCommand();
}

string ZSCAN(
	string key,
	// Redis type: integer
	int cursor,
	string pattern = "",
	// Redis type: integer
	int count = 0
) {
  redisPushBinarySafe("ZSCAN");
  redisPushBinarySafe(key);
  redisPushBinarySafe(IntToString(cursor));
  if (pattern != "") redisPushBinarySafe(pattern);
  if (count != 0) redisPushBinarySafe(IntToString(count));
  return redisCommand();
}

