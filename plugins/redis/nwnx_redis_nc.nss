// Autogenerated on: 2015-11-30 15:31:05 +0100
#include "nwnx_redis_core"

// Skipping sub-command: CLIENT KILL/{"command"=>"TYPE", "type"=>"enum", "enum"=>["normal", "slave", "pubsub"], "optional"=>true} - not supported yet.
/**
 * APPEND
 *
 * Append a value to a key
 *
 * Time complexity: O(1). The amortized time complexity is O(1) assuming the appended value is
 * small and the already present value is of any size, since the dynamic string
 * library used by Redis will double the free space available on every
 * reallocation.
 * Annotated return value: integer
 */
string APPEND_NOCAST(
	string key,
	string value
);

/**
 * AUTH
 *
 * Authenticate to the server
 * Annotated return value: simple-string
 */
string AUTH_NOCAST(
	string password
);

/**
 * BGREWRITEAOF
 *
 * Asynchronously rewrite the append-only file
 * Annotated return value: simple-string
 */
string BGREWRITEAOF_NOCAST();

/**
 * BGSAVE
 *
 * Asynchronously save the dataset to disk
 * Annotated return value: simple-string
 */
string BGSAVE_NOCAST();

/**
 * BITCOUNT
 *
 * Count set bits in a string
 *
 * Time complexity: O(N)
 * Annotated return value: integer
 */
string BITCOUNT_NOCAST(
	string key,
	// Redis type: integer
	string start = "",
	// Redis type: integer
	string end = ""
);

/**
 * BITOP
 *
 * Perform bitwise operations between strings
 *
 * Time complexity: O(N)
 * Annotated return value: integer
 */
string BITOP_NOCAST(
	string operation,
	// Redis type: key
	string destkey,
	string key
);

/**
 * BITPOS
 *
 * Find first bit set or clear in a string
 *
 * Time complexity: O(N)
 * Annotated return value: integer
 */
string BITPOS_NOCAST(
	string key,
	// Redis type: integer
	string bit,
	// Redis type: integer
	string start = "",
	// Redis type: integer
	string end = ""
);

/**
 * BLPOP
 *
 * Remove and get the first element in a list, or block until one is available
 *
 * Time complexity: O(1)
 * Annotated return value: array
 */
string BLPOP_NOCAST(
	string key,
	// Redis type: integer
	string timeout
);

/**
 * BRPOP
 *
 * Remove and get the last element in a list, or block until one is available
 *
 * Time complexity: O(1)
 * Annotated return value: array
 */
string BRPOP_NOCAST(
	string key,
	// Redis type: integer
	string timeout
);

/**
 * BRPOPLPUSH
 *
 * Pop a value from a list, push it to another list and return it; or block until one is available
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string BRPOPLPUSH_NOCAST(
	// Redis type: key
	string source,
	// Redis type: key
	string destination,
	// Redis type: integer
	string timeout
);

/**
 * CLIENT KILL
 *
 * Kill the connection of a client
 *
 * Time complexity: O(N) where N is the number of client connections
 * Annotated return value: simple-string
 */
string CLIENT_KILL_NOCAST(
	string ip_port = "",
	// Redis type: integer
	string client_id = "",
	Skipping sub-command: CLIENT KILL/{"command"=>"TYPE", "type"=>"enum", "enum"=>["normal", "slave", "pubsub"], "optional"=>true} - not supported yet.  = "",
	string ip_port = "",
	string yes_no = ""
);

/**
 * CLIENT LIST
 *
 * Get the list of client connections
 *
 * Time complexity: O(N) where N is the number of client connections
 * Annotated return value: bulk-string
 */
string CLIENT_LIST_NOCAST();

/**
 * CLIENT GETNAME
 *
 * Get the current connection name
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string CLIENT_GETNAME_NOCAST();

/**
 * CLIENT PAUSE
 *
 * Stop processing commands from clients for some time
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLIENT_PAUSE_NOCAST(
	// Redis type: integer
	string timeout
);

/**
 * CLIENT SETNAME
 *
 * Set the current connection name
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLIENT_SETNAME_NOCAST(
	string connection_name
);

/**
 * CLUSTER ADDSLOTS
 *
 * Assign new hash slots to receiving node
 *
 * Time complexity: O(N) where N is the total number of hash slot arguments
 * Annotated return value: simple-string
 */
string CLUSTER_ADDSLOTS_NOCAST(
	// Redis type: integer
	string slot
);

/**
 * CLUSTER COUNT_FAILURE_REPORTS
 *
 * Return the number of failure reports active for a given node
 *
 * Time complexity: O(N) where N is the number of failure reports
 * Annotated return value: 
 */
string CLUSTER_COUNT_FAILURE_REPORTS_NOCAST(
	string node_id
);

/**
 * CLUSTER COUNTKEYSINSLOT
 *
 * Return the number of local keys in the specified hash slot
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string CLUSTER_COUNTKEYSINSLOT_NOCAST(
	// Redis type: integer
	string slot
);

/**
 * CLUSTER DELSLOTS
 *
 * Set hash slots as unbound in receiving node
 *
 * Time complexity: O(N) where N is the total number of hash slot arguments
 * Annotated return value: simple-string
 */
string CLUSTER_DELSLOTS_NOCAST(
	// Redis type: integer
	string slot
);

/**
 * CLUSTER FAILOVER
 *
 * Forces a slave to perform a manual failover of its master.
 *
 * Time complexity: O(1)

 * - Valid values for options: "FORCE", "TAKEOVER"
 * Annotated return value: simple-string
 */
string CLUSTER_FAILOVER_NOCAST(
	// Redis type: enum
	string options = ""
);

/**
 * CLUSTER FORGET
 *
 * Remove a node from the nodes table
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLUSTER_FORGET_NOCAST(
	string node_id
);

/**
 * CLUSTER GETKEYSINSLOT
 *
 * Return local key names in the specified hash slot
 *
 * Time complexity: O(log(N)) where N is the number of requested keys
 * Annotated return value: array
 */
string CLUSTER_GETKEYSINSLOT_NOCAST(
	// Redis type: integer
	string slot,
	// Redis type: integer
	string count
);

/**
 * CLUSTER INFO
 *
 * Provides info about Redis Cluster node state
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string CLUSTER_INFO_NOCAST();

/**
 * CLUSTER KEYSLOT
 *
 * Returns the hash slot of the specified key
 *
 * Time complexity: O(N) where N is the number of bytes in the key
 * Annotated return value: integer
 */
string CLUSTER_KEYSLOT_NOCAST(
	string key
);

/**
 * CLUSTER MEET
 *
 * Force a node cluster to handshake with another node
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLUSTER_MEET_NOCAST(
	string ip,
	// Redis type: integer
	string port
);

/**
 * CLUSTER NODES
 *
 * Get Cluster config for the node
 *
 * Time complexity: O(N) where N is the total number of Cluster nodes
 * Annotated return value: bulk-string
 */
string CLUSTER_NODES_NOCAST();

/**
 * CLUSTER REPLICATE
 *
 * Reconfigure a node as a slave of the specified master node
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLUSTER_REPLICATE_NOCAST(
	string node_id
);

/**
 * CLUSTER RESET
 *
 * Reset a Redis Cluster node
 *
 * Time complexity: O(N) where N is the number of known nodes. The command may execute a
 * FLUSHALL as a side effect.

 * - Valid values for reset_type: "HARD", "SOFT"
 * Annotated return value: simple-string
 */
string CLUSTER_RESET_NOCAST(
	// Redis type: enum
	string reset_type = ""
);

/**
 * CLUSTER SAVECONFIG
 *
 * Forces the node to save cluster state on disk
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLUSTER_SAVECONFIG_NOCAST();

/**
 * CLUSTER SET_CONFIG_EPOCH
 *
 * Set the configuration epoch in a new node
 *
 * Time complexity: O(1)
 * Annotated return value: 
 */
string CLUSTER_SET_CONFIG_EPOCH_NOCAST(
	// Redis type: integer
	string config_epoch
);

/**
 * CLUSTER SETSLOT
 *
 * Bind an hash slot to a specific node
 *
 * Time complexity: O(1)

 * - Valid values for subcommand: "IMPORTING", "MIGRATING", "STABLE", "NODE"
 * Annotated return value: simple-string
 */
string CLUSTER_SETSLOT_NOCAST(
	// Redis type: integer
	string slot,
	// Redis type: enum
	string subcommand,
	string node_id = ""
);

/**
 * CLUSTER SLAVES
 *
 * List slave nodes of the specified master node
 *
 * Time complexity: O(1)
 * Annotated return value: 
 */
string CLUSTER_SLAVES_NOCAST(
	string node_id
);

/**
 * CLUSTER SLOTS
 *
 * Get array of Cluster slot to node mappings
 *
 * Time complexity: O(N) where N is the total number of Cluster nodes
 * Annotated return value: array
 */
string CLUSTER_SLOTS_NOCAST();

/**
 * COMMAND
 *
 * Get array of Redis command details
 *
 * Time complexity: O(N) where N is the total number of Redis commands
 * Annotated return value: array
 */
string COMMAND_NOCAST();

/**
 * COMMAND COUNT
 *
 * Get total number of Redis commands
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string COMMAND_COUNT_NOCAST();

/**
 * COMMAND GETKEYS
 *
 * Extract keys given a full Redis command
 *
 * Time complexity: O(N) where N is the number of arguments to the command
 * Annotated return value: array
 */
string COMMAND_GETKEYS_NOCAST();

/**
 * COMMAND INFO
 *
 * Get array of specific Redis command details
 *
 * Time complexity: O(N) when N is number of commands to look up
 * Annotated return value: array
 */
string COMMAND_INFO_NOCAST(
	string command_name
);

/**
 * CONFIG GET
 *
 * Get the value of a configuration parameter
 * Annotated return value: array
 */
string CONFIG_GET_NOCAST(
	string parameter
);

/**
 * CONFIG REWRITE
 *
 * Rewrite the configuration file with the in memory configuration
 * Annotated return value: simple-string
 */
string CONFIG_REWRITE_NOCAST();

/**
 * CONFIG SET
 *
 * Set a configuration parameter to the given value
 * Annotated return value: simple-string
 */
string CONFIG_SET_NOCAST(
	string parameter,
	string value
);

/**
 * CONFIG RESETSTAT
 *
 * Reset the stats returned by INFO
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CONFIG_RESETSTAT_NOCAST();

/**
 * DBSIZE
 *
 * Return the number of keys in the selected database
 * Annotated return value: integer
 */
string DBSIZE_NOCAST();

/**
 * DEBUG OBJECT
 *
 * Get debugging information about a key
 * Annotated return value: simple-string
 */
string DEBUG_OBJECT_NOCAST(
	string key
);

/**
 * DEBUG SEGFAULT
 *
 * Make the server crash
 * Annotated return value: simple-string
 */
string DEBUG_SEGFAULT_NOCAST();

/**
 * DECR
 *
 * Decrement the integer value of a key by one
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string DECR_NOCAST(
	string key
);

/**
 * DECRBY
 *
 * Decrement the integer value of a key by the given number
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string DECRBY_NOCAST(
	string key,
	// Redis type: integer
	string decrement
);

/**
 * DEL
 *
 * Delete a key
 *
 * Time complexity: O(N) where N is the number of keys that will be removed. When a key to
 * remove holds a value other than a string, the individual complexity for this
 * key is O(M) where M is the number of elements in the list, set, sorted set
 * or hash. Removing a single key that holds a string value is O(1).
 * Annotated return value: integer
 */
string DEL_NOCAST(
	string key
);

/**
 * DISCARD
 *
 * Discard all commands issued after MULTI
 * Annotated return value: simple-string
 */
string DISCARD_NOCAST();

/**
 * DUMP
 *
 * Return a serialized version of the value stored at the specified key.
 *
 * Time complexity: O(1) to access the key and additional O(N*M) to serialized it, where N is
 * the number of Redis objects composing the value and M their average size.
 * For small string values the time complexity is thus O(1)+O(1*M) where M is
 * small, so simply O(1).
 * Annotated return value: bulk-string
 */
string DUMP_NOCAST(
	string key
);

/**
 * ECHO
 *
 * Echo the given string
 * Annotated return value: bulk-string
 */
string ECHO_NOCAST(
	string message
);

/**
 * EVAL
 *
 * Execute a Lua script server side
 *
 * Time complexity: Depends on the script that is executed.
 * Annotated return value: 
 */
string EVAL_NOCAST(
	string script,
	// Redis type: integer
	string numkeys,
	string key,
	string arg
);

/**
 * EVALSHA
 *
 * Execute a Lua script server side
 *
 * Time complexity: Depends on the script that is executed.
 * Annotated return value: 
 */
string EVALSHA_NOCAST(
	string sha1,
	// Redis type: integer
	string numkeys,
	string key,
	string arg
);

/**
 * EXEC
 *
 * Execute all commands issued after MULTI
 * Annotated return value: array
 */
string EXEC_NOCAST();

/**
 * EXISTS
 *
 * Determine if a key exists
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string EXISTS_NOCAST(
	string key
);

/**
 * EXPIRE
 *
 * Set a key's time to live in seconds
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string EXPIRE_NOCAST(
	string key,
	// Redis type: integer
	string seconds
);

/**
 * EXPIREAT
 *
 * Set the expiration for a key as a UNIX timestamp
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string EXPIREAT_NOCAST(
	string key,
	// Redis type: posix time
	string timestamp
);

/**
 * FLUSHALL
 *
 * Remove all keys from all databases
 * Annotated return value: simple-string
 */
string FLUSHALL_NOCAST();

/**
 * FLUSHDB
 *
 * Remove all keys from the current database
 * Annotated return value: simple-string
 */
string FLUSHDB_NOCAST();

/**
 * GEOADD
 *
 * Add one or more geospatial items in the geospatial index represented using a sorted set
 *
 * Time complexity: O(log(N)) for each item added, where N is the number of elements in the
 * sorted set.
 * Annotated return value: integer
 */
string GEOADD_NOCAST(
	string key,
	// Redis type: double
	string longitude,
	// Redis type: double
	string latitude,
	string member
);

/**
 * GEOHASH
 *
 * Returns members of a geospatial index as standard geohash strings
 *
 * Time complexity: O(log(N)) for each member requested, where N is the number of elements in
 * the sorted set.
 * Annotated return value: array
 */
string GEOHASH_NOCAST(
	string key,
	string member
);

/**
 * GEOPOS
 *
 * Returns longitude and latitude of members of a geospatial index
 *
 * Time complexity: O(log(N)) for each member requested, where N is the number of elements in
 * the sorted set.
 * Annotated return value: array
 */
string GEOPOS_NOCAST(
	string key,
	string member
);

/**
 * GEODIST
 *
 * Returns the distance between two members of a geospatial index
 *
 * Time complexity: O(log(N))
 * Annotated return value: bulk-string
 */
string GEODIST_NOCAST(
	string key,
	string member1,
	string member2,
	string unit = ""
);

/**
 * GEORADIUS
 *
 * Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point
 *
 * Time complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the
 * circular area delimited by center and radius and M is the number of items
 * inside the index.

 * - Valid values for unit: "m", "km", "ft", "mi"

 * - Valid values for withcoord: "WITHCOORD"

 * - Valid values for withdist: "WITHDIST"

 * - Valid values for withhash: "WITHHASH"
 * Annotated return value: array
 */
string GEORADIUS_NOCAST(
	string key,
	// Redis type: double
	string longitude,
	// Redis type: double
	string latitude,
	// Redis type: double
	string radius,
	// Redis type: enum
	string unit,
	// Redis type: enum
	string withcoord = "",
	// Redis type: enum
	string withdist = "",
	// Redis type: enum
	string withhash = ""
);

/**
 * GEORADIUSBYMEMBER
 *
 * Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member
 *
 * Time complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the
 * circular area delimited by center and radius and M is the number of items
 * inside the index.

 * - Valid values for unit: "m", "km", "ft", "mi"

 * - Valid values for withcoord: "WITHCOORD"

 * - Valid values for withdist: "WITHDIST"

 * - Valid values for withhash: "WITHHASH"
 * Annotated return value: 
 */
string GEORADIUSBYMEMBER_NOCAST(
	string key,
	string member,
	// Redis type: double
	string radius,
	// Redis type: enum
	string unit,
	// Redis type: enum
	string withcoord = "",
	// Redis type: enum
	string withdist = "",
	// Redis type: enum
	string withhash = ""
);

/**
 * GET
 *
 * Get the value of a key
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string GET_NOCAST(
	string key
);

/**
 * GETBIT
 *
 * Returns the bit value at offset in the string value stored at key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string GETBIT_NOCAST(
	string key,
	// Redis type: integer
	string offset
);

/**
 * GETRANGE
 *
 * Get a substring of the string stored at a key
 *
 * Time complexity: O(N) where N is the length of the returned string. The complexity is
 * ultimately determined by the returned length, but because creating a
 * substring from an existing string is very cheap, it can be considered O(1)
 * for small strings.
 * Annotated return value: bulk-string
 */
string GETRANGE_NOCAST(
	string key,
	// Redis type: integer
	string start,
	// Redis type: integer
	string end
);

/**
 * GETSET
 *
 * Set the string value of a key and return its old value
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string GETSET_NOCAST(
	string key,
	string value
);

/**
 * HDEL
 *
 * Delete one or more hash fields
 *
 * Time complexity: O(N) where N is the number of fields to be removed.
 * Annotated return value: integer
 */
string HDEL_NOCAST(
	string key,
	string field
);

/**
 * HEXISTS
 *
 * Determine if a hash field exists
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string HEXISTS_NOCAST(
	string key,
	string field
);

/**
 * HGET
 *
 * Get the value of a hash field
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string HGET_NOCAST(
	string key,
	string field
);

/**
 * HGETALL
 *
 * Get all the fields and values in a hash
 *
 * Time complexity: O(N) where N is the size of the hash.
 * Annotated return value: array
 */
string HGETALL_NOCAST(
	string key
);

/**
 * HINCRBY
 *
 * Increment the integer value of a hash field by the given number
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string HINCRBY_NOCAST(
	string key,
	string field,
	// Redis type: integer
	string increment
);

/**
 * HINCRBYFLOAT
 *
 * Increment the float value of a hash field by the given amount
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string HINCRBYFLOAT_NOCAST(
	string key,
	string field,
	// Redis type: double
	string increment
);

/**
 * HKEYS
 *
 * Get all the fields in a hash
 *
 * Time complexity: O(N) where N is the size of the hash.
 * Annotated return value: array
 */
string HKEYS_NOCAST(
	string key
);

/**
 * HLEN
 *
 * Get the number of fields in a hash
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string HLEN_NOCAST(
	string key
);

/**
 * HMGET
 *
 * Get the values of all the given hash fields
 *
 * Time complexity: O(N) where N is the number of fields being requested.
 * Annotated return value: array
 */
string HMGET_NOCAST(
	string key,
	string field
);

/**
 * HMSET
 *
 * Set multiple hash fields to multiple values
 *
 * Time complexity: O(N) where N is the number of fields being set.
 * Annotated return value: simple-string
 */
string HMSET_NOCAST(
	string key,
	string field,
	string value
);

/**
 * HSET
 *
 * Set the string value of a hash field
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string HSET_NOCAST(
	string key,
	string field,
	string value
);

/**
 * HSETNX
 *
 * Set the value of a hash field, only if the field does not exist
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string HSETNX_NOCAST(
	string key,
	string field,
	string value
);

/**
 * HSTRLEN
 *
 * Get the length of the value of a hash field
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string HSTRLEN_NOCAST(
	string key,
	string field
);

/**
 * HVALS
 *
 * Get all the values in a hash
 *
 * Time complexity: O(N) where N is the size of the hash.
 * Annotated return value: array
 */
string HVALS_NOCAST(
	string key
);

/**
 * INCR
 *
 * Increment the integer value of a key by one
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string INCR_NOCAST(
	string key
);

/**
 * INCRBY
 *
 * Increment the integer value of a key by the given amount
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string INCRBY_NOCAST(
	string key,
	// Redis type: integer
	string increment
);

/**
 * INCRBYFLOAT
 *
 * Increment the float value of a key by the given amount
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string INCRBYFLOAT_NOCAST(
	string key,
	// Redis type: double
	string increment
);

/**
 * INFO
 *
 * Get information and statistics about the server
 * Annotated return value: bulk-string
 */
string INFO_NOCAST(
	string section = ""
);

/**
 * KEYS
 *
 * Find all keys matching the given pattern
 *
 * Time complexity: O(N) with N being the number of keys in the database, under the assumption
 * that the key names in the database and the given pattern have limited
 * length.
 * Annotated return value: array
 */
string KEYS_NOCAST(
	string pattern
);

/**
 * LASTSAVE
 *
 * Get the UNIX time stamp of the last successful save to disk
 * Annotated return value: integer
 */
string LASTSAVE_NOCAST();

/**
 * LINDEX
 *
 * Get an element from a list by its index
 *
 * Time complexity: O(N) where N is the number of elements to traverse to get to the element at
 * index. This makes asking for the first or the last element of the list O(1).
 * Annotated return value: bulk-string
 */
string LINDEX_NOCAST(
	string key,
	// Redis type: integer
	string index
);

/**
 * LINSERT
 *
 * Insert an element before or after another element in a list
 *
 * Time complexity: O(N) where N is the number of elements to traverse before seeing the value
 * pivot. This means that inserting somewhere on the left end on the list
 * (head) can be considered O(1) and inserting somewhere on the right end
 * (tail) is O(N).

 * - Valid values for where: "BEFORE", "AFTER"
 * Annotated return value: integer
 */
string LINSERT_NOCAST(
	string key,
	// Redis type: enum
	string where,
	string pivot,
	string value
);

/**
 * LLEN
 *
 * Get the length of a list
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string LLEN_NOCAST(
	string key
);

/**
 * LPOP
 *
 * Remove and get the first element in a list
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string LPOP_NOCAST(
	string key
);

/**
 * LPUSH
 *
 * Prepend one or multiple values to a list
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string LPUSH_NOCAST(
	string key,
	string value
);

/**
 * LPUSHX
 *
 * Prepend a value to a list, only if the list exists
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string LPUSHX_NOCAST(
	string key,
	string value
);

/**
 * LRANGE
 *
 * Get a range of elements from a list
 *
 * Time complexity: O(S+N) where S is the distance of start offset from HEAD for small lists,
 * from nearest end (HEAD or TAIL) for large lists; and N is the number of
 * elements in the specified range.
 * Annotated return value: array
 */
string LRANGE_NOCAST(
	string key,
	// Redis type: integer
	string start,
	// Redis type: integer
	string stop
);

/**
 * LREM
 *
 * Remove elements from a list
 *
 * Time complexity: O(N) where N is the length of the list.
 * Annotated return value: integer
 */
string LREM_NOCAST(
	string key,
	// Redis type: integer
	string count,
	string value
);

/**
 * LSET
 *
 * Set the value of an element in a list by its index
 *
 * Time complexity: O(N) where N is the length of the list. Setting either the first or the last
 * element of the list is O(1).
 * Annotated return value: simple-string
 */
string LSET_NOCAST(
	string key,
	// Redis type: integer
	string index,
	string value
);

/**
 * LTRIM
 *
 * Trim a list to the specified range
 *
 * Time complexity: O(N) where N is the number of elements to be removed by the operation.
 * Annotated return value: simple-string
 */
string LTRIM_NOCAST(
	string key,
	// Redis type: integer
	string start,
	// Redis type: integer
	string stop
);

/**
 * MGET
 *
 * Get the values of all the given keys
 *
 * Time complexity: O(N) where N is the number of keys to retrieve.
 * Annotated return value: array
 */
string MGET_NOCAST(
	string key
);

/**
 * MIGRATE
 *
 * Atomically transfer a key from a Redis instance to another one.
 *
 * Time complexity: This command actually executes a DUMP+DEL in the source instance, and a
 * RESTORE in the target instance. See the pages of these commands for time
 * complexity. Also an O(N) data transfer between the two instances is
 * performed.

 * - Valid values for copy: "COPY"

 * - Valid values for replace: "REPLACE"
 * Annotated return value: simple-string
 */
string MIGRATE_NOCAST(
	string host,
	string port,
	string key,
	// Redis type: integer
	string destination_db,
	// Redis type: integer
	string timeout,
	// Redis type: enum
	string copy = "",
	// Redis type: enum
	string replace = ""
);

/**
 * MONITOR
 *
 * Listen for all requests received by the server in real time
 * Annotated return value: 
 */
string MONITOR_NOCAST();

/**
 * MOVE
 *
 * Move a key to another database
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string MOVE_NOCAST(
	string key,
	// Redis type: integer
	string db
);

/**
 * MSET
 *
 * Set multiple keys to multiple values
 *
 * Time complexity: O(N) where N is the number of keys to set.
 * Annotated return value: simple-string
 */
string MSET_NOCAST(
	string key,
	string value
);

/**
 * MSETNX
 *
 * Set multiple keys to multiple values, only if none of the keys exist
 *
 * Time complexity: O(N) where N is the number of keys to set.
 * Annotated return value: integer
 */
string MSETNX_NOCAST(
	string key,
	string value
);

/**
 * MULTI
 *
 * Mark the start of a transaction block
 * Annotated return value: simple-string
 */
string MULTI_NOCAST();

/**
 * OBJECT
 *
 * Inspect the internals of Redis objects
 *
 * Time complexity: O(1) for all the currently implemented subcommands.
 * Annotated return value: 
 */
string OBJECT_NOCAST(
	string subcommand,
	string arguments = ""
);

/**
 * PERSIST
 *
 * Remove the expiration from a key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string PERSIST_NOCAST(
	string key
);

/**
 * PEXPIRE
 *
 * Set a key's time to live in milliseconds
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string PEXPIRE_NOCAST(
	string key,
	// Redis type: integer
	string milliseconds
);

/**
 * PEXPIREAT
 *
 * Set the expiration for a key as a UNIX timestamp specified in milliseconds
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string PEXPIREAT_NOCAST(
	string key,
	// Redis type: posix time
	string milliseconds_timestamp
);

/**
 * PFADD
 *
 * Adds the specified elements to the specified HyperLogLog.
 *
 * Time complexity: O(1) to add every element.
 * Annotated return value: integer
 */
string PFADD_NOCAST(
	string key,
	string element
);

/**
 * PFCOUNT
 *
 * Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).
 *
 * Time complexity: O(1) with every small average constant times when called with a single key.
 * O(N) with N being the number of keys, and much bigger constant times, when
 * called with multiple keys.
 * Annotated return value: integer
 */
string PFCOUNT_NOCAST(
	string key
);

/**
 * PFMERGE
 *
 * Merge N different HyperLogLogs into a single one.
 *
 * Time complexity: O(N) to merge N HyperLogLogs, but with high constant times.
 * Annotated return value: simple-string
 */
string PFMERGE_NOCAST(
	// Redis type: key
	string destkey,
	// Redis type: key
	string sourcekey
);

/**
 * PING
 *
 * Ping the server
 * Annotated return value: simple-string
 */
string PING_NOCAST();

/**
 * PSETEX
 *
 * Set the value and expiration in milliseconds of a key
 *
 * Time complexity: O(1)
 * Annotated return value: 
 */
string PSETEX_NOCAST(
	string key,
	// Redis type: integer
	string milliseconds,
	string value
);

/**
 * PUBSUB
 *
 * Inspect the state of the Pub/Sub subsystem
 *
 * Time complexity: O(N) for the CHANNELS subcommand, where N is the number of active channels,
 * and assuming constant time pattern matching (relatively short channels and
 * patterns). O(N) for the NUMSUB subcommand, where N is the number of
 * requested channels. O(1) for the NUMPAT subcommand.
 * Annotated return value: array
 */
string PUBSUB_NOCAST(
	string subcommand,
	string argument = ""
);

/**
 * PTTL
 *
 * Get the time to live for a key in milliseconds
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string PTTL_NOCAST(
	string key
);

/**
 * PUBLISH
 *
 * Post a message to a channel
 *
 * Time complexity: O(N+M) where N is the number of clients subscribed to the receiving channel
 * and M is the total number of subscribed patterns (by any client).
 * Annotated return value: integer
 */
string PUBLISH_NOCAST(
	string channel,
	string message
);

/**
 * QUIT
 *
 * Close the connection
 * Annotated return value: simple-string
 */
string QUIT_NOCAST();

/**
 * RANDOMKEY
 *
 * Return a random key from the keyspace
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string RANDOMKEY_NOCAST();

/**
 * RENAME
 *
 * Rename a key
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string RENAME_NOCAST(
	string key,
	// Redis type: key
	string newkey
);

/**
 * RENAMENX
 *
 * Rename a key, only if the new key does not exist
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string RENAMENX_NOCAST(
	string key,
	// Redis type: key
	string newkey
);

/**
 * RESTORE
 *
 * Create a key using the provided serialized value, previously obtained using DUMP.
 *
 * Time complexity: O(1) to create the new key and additional O(N*M) to reconstruct the
 * serialized value, where N is the number of Redis objects composing the value
 * and M their average size. For small string values the time complexity is
 * thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set
 * values the complexity is O(N*M*log(N)) because inserting values into sorted
 * sets is O(log(N)).

 * - Valid values for replace: "REPLACE"
 * Annotated return value: simple-string
 */
string RESTORE_NOCAST(
	string key,
	// Redis type: integer
	string ttl,
	string serialized_value,
	// Redis type: enum
	string replace = ""
);

/**
 * ROLE
 *
 * Return the role of the instance in the context of replication
 * Annotated return value: array
 */
string ROLE_NOCAST();

/**
 * RPOP
 *
 * Remove and get the last element in a list
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string RPOP_NOCAST(
	string key
);

/**
 * RPOPLPUSH
 *
 * Remove the last element in a list, prepend it to another list and return it
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string RPOPLPUSH_NOCAST(
	// Redis type: key
	string source,
	// Redis type: key
	string destination
);

/**
 * RPUSH
 *
 * Append one or multiple values to a list
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string RPUSH_NOCAST(
	string key,
	string value
);

/**
 * RPUSHX
 *
 * Append a value to a list, only if the list exists
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string RPUSHX_NOCAST(
	string key,
	string value
);

/**
 * SADD
 *
 * Add one or more members to a set
 *
 * Time complexity: O(N) where N is the number of members to be added.
 * Annotated return value: integer
 */
string SADD_NOCAST(
	string key,
	string member
);

/**
 * SAVE
 *
 * Synchronously save the dataset to disk
 * Annotated return value: simple-string
 */
string SAVE_NOCAST();

/**
 * SCARD
 *
 * Get the number of members in a set
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string SCARD_NOCAST(
	string key
);

/**
 * SCRIPT EXISTS
 *
 * Check existence of scripts in the script cache.
 *
 * Time complexity: O(N) with N being the number of scripts to check (so checking a single
 * script is an O(1) operation).
 * Annotated return value: array
 */
string SCRIPT_EXISTS_NOCAST(
	string script
);

/**
 * SCRIPT FLUSH
 *
 * Remove all the scripts from the script cache.
 *
 * Time complexity: O(N) with N being the number of scripts in cache
 * Annotated return value: simple-string
 */
string SCRIPT_FLUSH_NOCAST();

/**
 * SCRIPT KILL
 *
 * Kill the script currently in execution.
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string SCRIPT_KILL_NOCAST();

/**
 * SCRIPT LOAD
 *
 * Load the specified Lua script into the script cache.
 *
 * Time complexity: O(N) with N being the length in bytes of the script body.
 * Annotated return value: bulk-string
 */
string SCRIPT_LOAD_NOCAST(
	string script
);

/**
 * SDIFF
 *
 * Subtract multiple sets
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 * Annotated return value: array
 */
string SDIFF_NOCAST(
	string key
);

/**
 * SDIFFSTORE
 *
 * Subtract multiple sets and store the resulting set in a key
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 * Annotated return value: integer
 */
string SDIFFSTORE_NOCAST(
	// Redis type: key
	string destination,
	string key
);

/**
 * SELECT
 *
 * Change the selected database for the current connection
 * Annotated return value: simple-string
 */
string SELECT_NOCAST(
	// Redis type: integer
	string index
);

/**
 * SET
 *
 * Set the string value of a key
 *
 * Time complexity: O(1)

 * - Valid values for condition: "NX", "XX"
 * Annotated return value: simple-string
 */
string SET_NOCAST(
	string key,
	string value,
	// Redis type: integer
	string seconds = "",
	// Redis type: integer
	string milliseconds = "",
	// Redis type: enum
	string condition = ""
);

/**
 * SETBIT
 *
 * Sets or clears the bit at offset in the string value stored at key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string SETBIT_NOCAST(
	string key,
	// Redis type: integer
	string offset,
	string value
);

/**
 * SETEX
 *
 * Set the value and expiration of a key
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string SETEX_NOCAST(
	string key,
	// Redis type: integer
	string seconds,
	string value
);

/**
 * SETNX
 *
 * Set the value of a key, only if the key does not exist
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string SETNX_NOCAST(
	string key,
	string value
);

/**
 * SETRANGE
 *
 * Overwrite part of a string at key starting at the specified offset
 *
 * Time complexity: O(1), not counting the time taken to copy the new string in place. Usually,
 * this string is very small so the amortized complexity is O(1). Otherwise,
 * complexity is O(M) with M being the length of the value argument.
 * Annotated return value: integer
 */
string SETRANGE_NOCAST(
	string key,
	// Redis type: integer
	string offset,
	string value
);

/**
 * SHUTDOWN
 *
 * Synchronously save the dataset to disk and then shut down the server

 * - Valid values for NOSAVE: "NOSAVE"

 * - Valid values for SAVE: "SAVE"
 * Annotated return value: simple-string
 */
string SHUTDOWN_NOCAST(
	// Redis type: enum
	string NOSAVE = "",
	// Redis type: enum
	string SAVE = ""
);

/**
 * SINTER
 *
 * Intersect multiple sets
 *
 * Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is
 * the number of sets.
 * Annotated return value: array
 */
string SINTER_NOCAST(
	string key
);

/**
 * SINTERSTORE
 *
 * Intersect multiple sets and store the resulting set in a key
 *
 * Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is
 * the number of sets.
 * Annotated return value: integer
 */
string SINTERSTORE_NOCAST(
	// Redis type: key
	string destination,
	string key
);

/**
 * SISMEMBER
 *
 * Determine if a given value is a member of a set
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string SISMEMBER_NOCAST(
	string key,
	string member
);

/**
 * SLAVEOF
 *
 * Make the server a slave of another instance, or promote it as master
 * Annotated return value: simple-string
 */
string SLAVEOF_NOCAST(
	string host,
	string port
);

/**
 * SLOWLOG
 *
 * Manages the Redis slow queries log
 * Annotated return value: 
 */
string SLOWLOG_NOCAST(
	string subcommand,
	string argument = ""
);

/**
 * SMEMBERS
 *
 * Get all the members in a set
 *
 * Time complexity: O(N) where N is the set cardinality.
 * Annotated return value: array
 */
string SMEMBERS_NOCAST(
	string key
);

/**
 * SMOVE
 *
 * Move a member from one set to another
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string SMOVE_NOCAST(
	// Redis type: key
	string source,
	// Redis type: key
	string destination,
	string member
);

/**
 * SORT
 *
 * Sort the elements in a list, set or sorted set
 *
 * Time complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort,
 * and M the number of returned elements. When the elements are not sorted,
 * complexity is currently O(N) as there is a copy step that will be avoided in
 * next releases.

 * - Valid values for order: "ASC", "DESC"

 * - Valid values for sorting: "ALPHA"
 * Annotated return value: array
 */
string SORT_NOCAST(
	string key,
	string pattern = "",
	// Redis type: integer
	string offset = "",
	// Redis type: integer
	string count = "",
	string pattern = "",
	// Redis type: enum
	string order = "",
	// Redis type: enum
	string sorting = "",
	// Redis type: key
	string destination = ""
);

/**
 * SPOP
 *
 * Remove and return one or multiple random members from a set
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string SPOP_NOCAST(
	string key,
	// Redis type: integer
	string count = ""
);

/**
 * SRANDMEMBER
 *
 * Get one or multiple random members from a set
 *
 * Time complexity: Without the count argument O(1), otherwise O(N) where N is the absolute
 * value of the passed count.
 * Annotated return value: bulk-string
 */
string SRANDMEMBER_NOCAST(
	string key,
	// Redis type: integer
	string count = ""
);

/**
 * SREM
 *
 * Remove one or more members from a set
 *
 * Time complexity: O(N) where N is the number of members to be removed.
 * Annotated return value: integer
 */
string SREM_NOCAST(
	string key,
	string member
);

/**
 * STRLEN
 *
 * Get the length of the value stored in a key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string STRLEN_NOCAST(
	string key
);

/**
 * SUNION
 *
 * Add multiple sets
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 * Annotated return value: array
 */
string SUNION_NOCAST(
	string key
);

/**
 * SUNIONSTORE
 *
 * Add multiple sets and store the resulting set in a key
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 * Annotated return value: integer
 */
string SUNIONSTORE_NOCAST(
	// Redis type: key
	string destination,
	string key
);

/**
 * SYNC
 *
 * Internal command used for replication
 * Annotated return value: 
 */
string SYNC_NOCAST();

/**
 * TIME
 *
 * Return the current server time
 *
 * Time complexity: O(1)
 * Annotated return value: array
 */
string TIME_NOCAST();

/**
 * TTL
 *
 * Get the time to live for a key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string TTL_NOCAST(
	string key
);

/**
 * TYPE
 *
 * Determine the type stored at key
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string TYPE_NOCAST(
	string key
);

/**
 * UNWATCH
 *
 * Forget about all watched keys
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string UNWATCH_NOCAST();

/**
 * WAIT
 *
 * Wait for the synchronous replication of all the write commands sent in the context of the current connection
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string WAIT_NOCAST(
	// Redis type: integer
	string numslaves,
	// Redis type: integer
	string timeout
);

/**
 * WATCH
 *
 * Watch the given keys to determine execution of the MULTI/EXEC block
 *
 * Time complexity: O(1) for every key.
 * Annotated return value: simple-string
 */
string WATCH_NOCAST(
	string key
);

/**
 * ZADD
 *
 * Add one or more members to a sorted set, or update its score if it already exists
 *
 * Time complexity: O(log(N)) for each item added, where N is the number of elements in the
 * sorted set.

 * - Valid values for condition: "NX", "XX"

 * - Valid values for change: "CH"

 * - Valid values for increment: "INCR"
 * Annotated return value: integer
 */
string ZADD_NOCAST(
	string key,
	// Redis type: enum
	string condition = "",
	// Redis type: enum
	string change = "",
	// Redis type: enum
	string increment = "",
	// Redis type: double
	string score = "",
	string member = ""
);

/**
 * ZCARD
 *
 * Get the number of members in a sorted set
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
string ZCARD_NOCAST(
	string key
);

/**
 * ZCOUNT
 *
 * Count the members in a sorted set with scores within the given values
 *
 * Time complexity: O(log(N)) with N being the number of elements in the sorted set.
 * Annotated return value: integer
 */
string ZCOUNT_NOCAST(
	string key,
	// Redis type: double
	string min,
	// Redis type: double
	string max
);

/**
 * ZINCRBY
 *
 * Increment the score of a member in a sorted set
 *
 * Time complexity: O(log(N)) where N is the number of elements in the sorted set.
 * Annotated return value: bulk-string
 */
string ZINCRBY_NOCAST(
	string key,
	// Redis type: integer
	string increment,
	string member
);

/**
 * ZINTERSTORE
 *
 * Intersect multiple sorted sets and store the resulting sorted set in a new key
 *
 * Time complexity: O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K
 * being the number of input sorted sets and M being the number of elements in
 * the resulting sorted set.

 * - Valid values for aggregate: "SUM", "MIN", "MAX"
 * Annotated return value: integer
 */
string ZINTERSTORE_NOCAST(
	// Redis type: key
	string destination,
	// Redis type: integer
	string numkeys,
	string key,
	// Redis type: integer
	string weight = "",
	// Redis type: enum
	string aggregate = ""
);

/**
 * ZLEXCOUNT
 *
 * Count the number of members in a sorted set between a given lexicographical range
 *
 * Time complexity: O(log(N)) with N being the number of elements in the sorted set.
 * Annotated return value: integer
 */
string ZLEXCOUNT_NOCAST(
	string key,
	string min,
	string max
);

/**
 * ZRANGE
 *
 * Return a range of members in a sorted set, by index
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements returned.

 * - Valid values for withscores: "WITHSCORES"
 * Annotated return value: array
 */
string ZRANGE_NOCAST(
	string key,
	// Redis type: integer
	string start,
	// Redis type: integer
	string stop,
	// Redis type: enum
	string withscores = ""
);

/**
 * ZRANGEBYLEX
 *
 * Return a range of members in a sorted set, by lexicographical range
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements being returned. If M is constant (e.g. always asking for
 * the first 10 elements with LIMIT), you can consider it O(log(N)).
 * Annotated return value: array
 */
string ZRANGEBYLEX_NOCAST(
	string key,
	string min,
	string max,
	// Redis type: integer
	string offset = "",
	// Redis type: integer
	string count = ""
);

/**
 * ZREVRANGEBYLEX
 *
 * Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements being returned. If M is constant (e.g. always asking for
 * the first 10 elements with LIMIT), you can consider it O(log(N)).
 * Annotated return value: array
 */
string ZREVRANGEBYLEX_NOCAST(
	string key,
	string max,
	string min,
	// Redis type: integer
	string offset = "",
	// Redis type: integer
	string count = ""
);

/**
 * ZRANGEBYSCORE
 *
 * Return a range of members in a sorted set, by score
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements being returned. If M is constant (e.g. always asking for
 * the first 10 elements with LIMIT), you can consider it O(log(N)).

 * - Valid values for withscores: "WITHSCORES"
 * Annotated return value: array
 */
string ZRANGEBYSCORE_NOCAST(
	string key,
	// Redis type: double
	string min,
	// Redis type: double
	string max,
	// Redis type: enum
	string withscores = "",
	// Redis type: integer
	string offset = "",
	// Redis type: integer
	string count = ""
);

/**
 * ZRANK
 *
 * Determine the index of a member in a sorted set
 *
 * Time complexity: O(log(N))
 * Annotated return value: integer
 */
string ZRANK_NOCAST(
	string key,
	string member
);

/**
 * ZREM
 *
 * Remove one or more members from a sorted set
 *
 * Time complexity: O(M*log(N)) with N being the number of elements in the sorted set and M the
 * number of elements to be removed.
 * Annotated return value: integer
 */
string ZREM_NOCAST(
	string key,
	string member
);

/**
 * ZREMRANGEBYLEX
 *
 * Remove all members in a sorted set between the given lexicographical range
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements removed by the operation.
 * Annotated return value: integer
 */
string ZREMRANGEBYLEX_NOCAST(
	string key,
	string min,
	string max
);

/**
 * ZREMRANGEBYRANK
 *
 * Remove all members in a sorted set within the given indexes
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements removed by the operation.
 * Annotated return value: integer
 */
string ZREMRANGEBYRANK_NOCAST(
	string key,
	// Redis type: integer
	string start,
	// Redis type: integer
	string stop
);

/**
 * ZREMRANGEBYSCORE
 *
 * Remove all members in a sorted set within the given scores
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements removed by the operation.
 * Annotated return value: integer
 */
string ZREMRANGEBYSCORE_NOCAST(
	string key,
	// Redis type: double
	string min,
	// Redis type: double
	string max
);

/**
 * ZREVRANGE
 *
 * Return a range of members in a sorted set, by index, with scores ordered from high to low
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements returned.

 * - Valid values for withscores: "WITHSCORES"
 * Annotated return value: array
 */
string ZREVRANGE_NOCAST(
	string key,
	// Redis type: integer
	string start,
	// Redis type: integer
	string stop,
	// Redis type: enum
	string withscores = ""
);

/**
 * ZREVRANGEBYSCORE
 *
 * Return a range of members in a sorted set, by score, with scores ordered from high to low
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements being returned. If M is constant (e.g. always asking for
 * the first 10 elements with LIMIT), you can consider it O(log(N)).

 * - Valid values for withscores: "WITHSCORES"
 * Annotated return value: array
 */
string ZREVRANGEBYSCORE_NOCAST(
	string key,
	// Redis type: double
	string max,
	// Redis type: double
	string min,
	// Redis type: enum
	string withscores = "",
	// Redis type: integer
	string offset = "",
	// Redis type: integer
	string count = ""
);

/**
 * ZREVRANK
 *
 * Determine the index of a member in a sorted set, with scores ordered from high to low
 *
 * Time complexity: O(log(N))
 * Annotated return value: integer
 */
string ZREVRANK_NOCAST(
	string key,
	string member
);

/**
 * ZSCORE
 *
 * Get the score associated with the given member in a sorted set
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string ZSCORE_NOCAST(
	string key,
	string member
);

/**
 * ZUNIONSTORE
 *
 * Add multiple sorted sets and store the resulting sorted set in a new key
 *
 * Time complexity: O(N)+O(M log(M)) with N being the sum of the sizes of the input sorted sets,
 * and M being the number of elements in the resulting sorted set.

 * - Valid values for aggregate: "SUM", "MIN", "MAX"
 * Annotated return value: integer
 */
string ZUNIONSTORE_NOCAST(
	// Redis type: key
	string destination,
	// Redis type: integer
	string numkeys,
	string key,
	// Redis type: integer
	string weight = "",
	// Redis type: enum
	string aggregate = ""
);

/**
 * SCAN
 *
 * Incrementally iterate the keys space
 *
 * Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command
 * calls for the cursor to return back to 0. N is the number of elements inside
 * the collection..
 * Annotated return value: 
 */
string SCAN_NOCAST(
	// Redis type: integer
	string cursor,
	string pattern = "",
	// Redis type: integer
	string count = ""
);

/**
 * SSCAN
 *
 * Incrementally iterate Set elements
 *
 * Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command
 * calls for the cursor to return back to 0. N is the number of elements inside
 * the collection..
 * Annotated return value: 
 */
string SSCAN_NOCAST(
	string key,
	// Redis type: integer
	string cursor,
	string pattern = "",
	// Redis type: integer
	string count = ""
);

/**
 * HSCAN
 *
 * Incrementally iterate hash fields and associated values
 *
 * Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command
 * calls for the cursor to return back to 0. N is the number of elements inside
 * the collection..
 * Annotated return value: 
 */
string HSCAN_NOCAST(
	string key,
	// Redis type: integer
	string cursor,
	string pattern = "",
	// Redis type: integer
	string count = ""
);

/**
 * ZSCAN
 *
 * Incrementally iterate sorted sets elements and associated scores
 *
 * Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command
 * calls for the cursor to return back to 0. N is the number of elements inside
 * the collection..
 * Annotated return value: 
 */
string ZSCAN_NOCAST(
	string key,
	// Redis type: integer
	string cursor,
	string pattern = "",
	// Redis type: integer
	string count = ""
);



// Implementation below
string APPEND_NOCAST(
	string key,
	string value
) {
  redisPushBinarySafe("APPEND");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return redisCommand();
}

string AUTH_NOCAST(
	string password
) {
  redisPushBinarySafe("AUTH");
  redisPushBinarySafe(password);
  return redisCommand();
}

string BGREWRITEAOF_NOCAST() {
  redisPushBinarySafe("BGREWRITEAOF");
  return redisCommand();
}

string BGSAVE_NOCAST() {
  redisPushBinarySafe("BGSAVE");
  return redisCommand();
}

string BITCOUNT_NOCAST(
	string key,
	// Redis type: integer
	string start = "",
	// Redis type: integer
	string end = ""
) {
  redisPushBinarySafe("BITCOUNT");
  redisPushBinarySafe(key);
  if (start != "") if (start != "") redisPushBinarySafe(start);
  if (end != "") if (end != "") redisPushBinarySafe(end);
  return redisCommand();
}

string BITOP_NOCAST(
	string operation,
	// Redis type: key
	string destkey,
	string key
) {
  redisPushBinarySafe("BITOP");
  redisPushBinarySafe(operation);
  redisPushBinarySafe(destkey);
  redisPushBinarySafe(key);
  return redisCommand();
}

string BITPOS_NOCAST(
	string key,
	// Redis type: integer
	string bit,
	// Redis type: integer
	string start = "",
	// Redis type: integer
	string end = ""
) {
  redisPushBinarySafe("BITPOS");
  redisPushBinarySafe(key);
  redisPushBinarySafe(bit);
  if (start != "") if (start != "") redisPushBinarySafe(start);
  if (end != "") if (end != "") redisPushBinarySafe(end);
  return redisCommand();
}

string BLPOP_NOCAST(
	string key,
	// Redis type: integer
	string timeout
) {
  redisPushBinarySafe("BLPOP");
  redisPushBinarySafe(key);
  redisPushBinarySafe(timeout);
  return redisCommand();
}

string BRPOP_NOCAST(
	string key,
	// Redis type: integer
	string timeout
) {
  redisPushBinarySafe("BRPOP");
  redisPushBinarySafe(key);
  redisPushBinarySafe(timeout);
  return redisCommand();
}

string BRPOPLPUSH_NOCAST(
	// Redis type: key
	string source,
	// Redis type: key
	string destination,
	// Redis type: integer
	string timeout
) {
  redisPushBinarySafe("BRPOPLPUSH");
  redisPushBinarySafe(source);
  redisPushBinarySafe(destination);
  redisPushBinarySafe(timeout);
  return redisCommand();
}

string CLIENT_KILL_NOCAST(
	string ip_port = "",
	// Redis type: integer
	string client_id = "",
	Skipping sub-command: CLIENT KILL/{"command"=>"TYPE", "type"=>"enum", "enum"=>["normal", "slave", "pubsub"], "optional"=>true} - not supported yet.  = "",
	string ip_port = "",
	string yes_no = ""
) {
  redisPushBinarySafe("CLIENT KILL");
  if (ip_port != "") if (ip_port != "") redisPushBinarySafe(ip_port);
  if (client_id != "") if (client_id != "") redisPushBinarySafe(client_id);
  redisPushBinarySafe();
  if (ip_port != "") if (ip_port != "") redisPushBinarySafe(ip_port);
  if (yes_no != "") if (yes_no != "") redisPushBinarySafe(yes_no);
  return redisCommand();
}

string CLIENT_LIST_NOCAST() {
  redisPushBinarySafe("CLIENT LIST");
  return redisCommand();
}

string CLIENT_GETNAME_NOCAST() {
  redisPushBinarySafe("CLIENT GETNAME");
  return redisCommand();
}

string CLIENT_PAUSE_NOCAST(
	// Redis type: integer
	string timeout
) {
  redisPushBinarySafe("CLIENT PAUSE");
  redisPushBinarySafe(timeout);
  return redisCommand();
}

string CLIENT_SETNAME_NOCAST(
	string connection_name
) {
  redisPushBinarySafe("CLIENT SETNAME");
  redisPushBinarySafe(connection_name);
  return redisCommand();
}

string CLUSTER_ADDSLOTS_NOCAST(
	// Redis type: integer
	string slot
) {
  redisPushBinarySafe("CLUSTER ADDSLOTS");
  redisPushBinarySafe(slot);
  return redisCommand();
}

string CLUSTER_COUNT_FAILURE_REPORTS_NOCAST(
	string node_id
) {
  redisPushBinarySafe("CLUSTER COUNT_FAILURE_REPORTS");
  redisPushBinarySafe(node_id);
  return redisCommand();
}

string CLUSTER_COUNTKEYSINSLOT_NOCAST(
	// Redis type: integer
	string slot
) {
  redisPushBinarySafe("CLUSTER COUNTKEYSINSLOT");
  redisPushBinarySafe(slot);
  return redisCommand();
}

string CLUSTER_DELSLOTS_NOCAST(
	// Redis type: integer
	string slot
) {
  redisPushBinarySafe("CLUSTER DELSLOTS");
  redisPushBinarySafe(slot);
  return redisCommand();
}

string CLUSTER_FAILOVER_NOCAST(
	// Redis type: enum
	string options = ""
) {
  redisPushBinarySafe("CLUSTER FAILOVER");
  if (options != "") if (options != "") redisPushBinarySafe(options);
  return redisCommand();
}

string CLUSTER_FORGET_NOCAST(
	string node_id
) {
  redisPushBinarySafe("CLUSTER FORGET");
  redisPushBinarySafe(node_id);
  return redisCommand();
}

string CLUSTER_GETKEYSINSLOT_NOCAST(
	// Redis type: integer
	string slot,
	// Redis type: integer
	string count
) {
  redisPushBinarySafe("CLUSTER GETKEYSINSLOT");
  redisPushBinarySafe(slot);
  redisPushBinarySafe(count);
  return redisCommand();
}

string CLUSTER_INFO_NOCAST() {
  redisPushBinarySafe("CLUSTER INFO");
  return redisCommand();
}

string CLUSTER_KEYSLOT_NOCAST(
	string key
) {
  redisPushBinarySafe("CLUSTER KEYSLOT");
  redisPushBinarySafe(key);
  return redisCommand();
}

string CLUSTER_MEET_NOCAST(
	string ip,
	// Redis type: integer
	string port
) {
  redisPushBinarySafe("CLUSTER MEET");
  redisPushBinarySafe(ip);
  redisPushBinarySafe(port);
  return redisCommand();
}

string CLUSTER_NODES_NOCAST() {
  redisPushBinarySafe("CLUSTER NODES");
  return redisCommand();
}

string CLUSTER_REPLICATE_NOCAST(
	string node_id
) {
  redisPushBinarySafe("CLUSTER REPLICATE");
  redisPushBinarySafe(node_id);
  return redisCommand();
}

string CLUSTER_RESET_NOCAST(
	// Redis type: enum
	string reset_type = ""
) {
  redisPushBinarySafe("CLUSTER RESET");
  if (reset_type != "") if (reset_type != "") redisPushBinarySafe(reset_type);
  return redisCommand();
}

string CLUSTER_SAVECONFIG_NOCAST() {
  redisPushBinarySafe("CLUSTER SAVECONFIG");
  return redisCommand();
}

string CLUSTER_SET_CONFIG_EPOCH_NOCAST(
	// Redis type: integer
	string config_epoch
) {
  redisPushBinarySafe("CLUSTER SET_CONFIG_EPOCH");
  redisPushBinarySafe(config_epoch);
  return redisCommand();
}

string CLUSTER_SETSLOT_NOCAST(
	// Redis type: integer
	string slot,
	// Redis type: enum
	string subcommand,
	string node_id = ""
) {
  redisPushBinarySafe("CLUSTER SETSLOT");
  redisPushBinarySafe(slot);
  redisPushBinarySafe(subcommand);
  if (node_id != "") if (node_id != "") redisPushBinarySafe(node_id);
  return redisCommand();
}

string CLUSTER_SLAVES_NOCAST(
	string node_id
) {
  redisPushBinarySafe("CLUSTER SLAVES");
  redisPushBinarySafe(node_id);
  return redisCommand();
}

string CLUSTER_SLOTS_NOCAST() {
  redisPushBinarySafe("CLUSTER SLOTS");
  return redisCommand();
}

string COMMAND_NOCAST() {
  redisPushBinarySafe("COMMAND");
  return redisCommand();
}

string COMMAND_COUNT_NOCAST() {
  redisPushBinarySafe("COMMAND COUNT");
  return redisCommand();
}

string COMMAND_GETKEYS_NOCAST() {
  redisPushBinarySafe("COMMAND GETKEYS");
  return redisCommand();
}

string COMMAND_INFO_NOCAST(
	string command_name
) {
  redisPushBinarySafe("COMMAND INFO");
  redisPushBinarySafe(command_name);
  return redisCommand();
}

string CONFIG_GET_NOCAST(
	string parameter
) {
  redisPushBinarySafe("CONFIG GET");
  redisPushBinarySafe(parameter);
  return redisCommand();
}

string CONFIG_REWRITE_NOCAST() {
  redisPushBinarySafe("CONFIG REWRITE");
  return redisCommand();
}

string CONFIG_SET_NOCAST(
	string parameter,
	string value
) {
  redisPushBinarySafe("CONFIG SET");
  redisPushBinarySafe(parameter);
  redisPushBinarySafe(value);
  return redisCommand();
}

string CONFIG_RESETSTAT_NOCAST() {
  redisPushBinarySafe("CONFIG RESETSTAT");
  return redisCommand();
}

string DBSIZE_NOCAST() {
  redisPushBinarySafe("DBSIZE");
  return redisCommand();
}

string DEBUG_OBJECT_NOCAST(
	string key
) {
  redisPushBinarySafe("DEBUG OBJECT");
  redisPushBinarySafe(key);
  return redisCommand();
}

string DEBUG_SEGFAULT_NOCAST() {
  redisPushBinarySafe("DEBUG SEGFAULT");
  return redisCommand();
}

string DECR_NOCAST(
	string key
) {
  redisPushBinarySafe("DECR");
  redisPushBinarySafe(key);
  return redisCommand();
}

string DECRBY_NOCAST(
	string key,
	// Redis type: integer
	string decrement
) {
  redisPushBinarySafe("DECRBY");
  redisPushBinarySafe(key);
  redisPushBinarySafe(decrement);
  return redisCommand();
}

string DEL_NOCAST(
	string key
) {
  redisPushBinarySafe("DEL");
  redisPushBinarySafe(key);
  return redisCommand();
}

string DISCARD_NOCAST() {
  redisPushBinarySafe("DISCARD");
  return redisCommand();
}

string DUMP_NOCAST(
	string key
) {
  redisPushBinarySafe("DUMP");
  redisPushBinarySafe(key);
  return redisCommand();
}

string ECHO_NOCAST(
	string message
) {
  redisPushBinarySafe("ECHO");
  redisPushBinarySafe(message);
  return redisCommand();
}

string EVAL_NOCAST(
	string script,
	// Redis type: integer
	string numkeys,
	string key,
	string arg
) {
  redisPushBinarySafe("EVAL");
  redisPushBinarySafe(script);
  redisPushBinarySafe(numkeys);
  redisPushBinarySafe(key);
  redisPushBinarySafe(arg);
  return redisCommand();
}

string EVALSHA_NOCAST(
	string sha1,
	// Redis type: integer
	string numkeys,
	string key,
	string arg
) {
  redisPushBinarySafe("EVALSHA");
  redisPushBinarySafe(sha1);
  redisPushBinarySafe(numkeys);
  redisPushBinarySafe(key);
  redisPushBinarySafe(arg);
  return redisCommand();
}

string EXEC_NOCAST() {
  redisPushBinarySafe("EXEC");
  return redisCommand();
}

string EXISTS_NOCAST(
	string key
) {
  redisPushBinarySafe("EXISTS");
  redisPushBinarySafe(key);
  return redisCommand();
}

string EXPIRE_NOCAST(
	string key,
	// Redis type: integer
	string seconds
) {
  redisPushBinarySafe("EXPIRE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(seconds);
  return redisCommand();
}

string EXPIREAT_NOCAST(
	string key,
	// Redis type: posix time
	string timestamp
) {
  redisPushBinarySafe("EXPIREAT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(timestamp);
  return redisCommand();
}

string FLUSHALL_NOCAST() {
  redisPushBinarySafe("FLUSHALL");
  return redisCommand();
}

string FLUSHDB_NOCAST() {
  redisPushBinarySafe("FLUSHDB");
  return redisCommand();
}

string GEOADD_NOCAST(
	string key,
	// Redis type: double
	string longitude,
	// Redis type: double
	string latitude,
	string member
) {
  redisPushBinarySafe("GEOADD");
  redisPushBinarySafe(key);
  redisPushBinarySafe(longitude);
  redisPushBinarySafe(latitude);
  redisPushBinarySafe(member);
  return redisCommand();
}

string GEOHASH_NOCAST(
	string key,
	string member
) {
  redisPushBinarySafe("GEOHASH");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return redisCommand();
}

string GEOPOS_NOCAST(
	string key,
	string member
) {
  redisPushBinarySafe("GEOPOS");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return redisCommand();
}

string GEODIST_NOCAST(
	string key,
	string member1,
	string member2,
	string unit = ""
) {
  redisPushBinarySafe("GEODIST");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member1);
  redisPushBinarySafe(member2);
  if (unit != "") if (unit != "") redisPushBinarySafe(unit);
  return redisCommand();
}

string GEORADIUS_NOCAST(
	string key,
	// Redis type: double
	string longitude,
	// Redis type: double
	string latitude,
	// Redis type: double
	string radius,
	// Redis type: enum
	string unit,
	// Redis type: enum
	string withcoord = "",
	// Redis type: enum
	string withdist = "",
	// Redis type: enum
	string withhash = ""
) {
  redisPushBinarySafe("GEORADIUS");
  redisPushBinarySafe(key);
  redisPushBinarySafe(longitude);
  redisPushBinarySafe(latitude);
  redisPushBinarySafe(radius);
  redisPushBinarySafe(unit);
  if (withcoord != "") if (withcoord != "") redisPushBinarySafe(withcoord);
  if (withdist != "") if (withdist != "") redisPushBinarySafe(withdist);
  if (withhash != "") if (withhash != "") redisPushBinarySafe(withhash);
  return redisCommand();
}

string GEORADIUSBYMEMBER_NOCAST(
	string key,
	string member,
	// Redis type: double
	string radius,
	// Redis type: enum
	string unit,
	// Redis type: enum
	string withcoord = "",
	// Redis type: enum
	string withdist = "",
	// Redis type: enum
	string withhash = ""
) {
  redisPushBinarySafe("GEORADIUSBYMEMBER");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  redisPushBinarySafe(radius);
  redisPushBinarySafe(unit);
  if (withcoord != "") if (withcoord != "") redisPushBinarySafe(withcoord);
  if (withdist != "") if (withdist != "") redisPushBinarySafe(withdist);
  if (withhash != "") if (withhash != "") redisPushBinarySafe(withhash);
  return redisCommand();
}

string GET_NOCAST(
	string key
) {
  redisPushBinarySafe("GET");
  redisPushBinarySafe(key);
  return redisCommand();
}

string GETBIT_NOCAST(
	string key,
	// Redis type: integer
	string offset
) {
  redisPushBinarySafe("GETBIT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(offset);
  return redisCommand();
}

string GETRANGE_NOCAST(
	string key,
	// Redis type: integer
	string start,
	// Redis type: integer
	string end
) {
  redisPushBinarySafe("GETRANGE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(start);
  redisPushBinarySafe(end);
  return redisCommand();
}

string GETSET_NOCAST(
	string key,
	string value
) {
  redisPushBinarySafe("GETSET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return redisCommand();
}

string HDEL_NOCAST(
	string key,
	string field
) {
  redisPushBinarySafe("HDEL");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  return redisCommand();
}

string HEXISTS_NOCAST(
	string key,
	string field
) {
  redisPushBinarySafe("HEXISTS");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  return redisCommand();
}

string HGET_NOCAST(
	string key,
	string field
) {
  redisPushBinarySafe("HGET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  return redisCommand();
}

string HGETALL_NOCAST(
	string key
) {
  redisPushBinarySafe("HGETALL");
  redisPushBinarySafe(key);
  return redisCommand();
}

string HINCRBY_NOCAST(
	string key,
	string field,
	// Redis type: integer
	string increment
) {
  redisPushBinarySafe("HINCRBY");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  redisPushBinarySafe(increment);
  return redisCommand();
}

string HINCRBYFLOAT_NOCAST(
	string key,
	string field,
	// Redis type: double
	string increment
) {
  redisPushBinarySafe("HINCRBYFLOAT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  redisPushBinarySafe(increment);
  return redisCommand();
}

string HKEYS_NOCAST(
	string key
) {
  redisPushBinarySafe("HKEYS");
  redisPushBinarySafe(key);
  return redisCommand();
}

string HLEN_NOCAST(
	string key
) {
  redisPushBinarySafe("HLEN");
  redisPushBinarySafe(key);
  return redisCommand();
}

string HMGET_NOCAST(
	string key,
	string field
) {
  redisPushBinarySafe("HMGET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  return redisCommand();
}

string HMSET_NOCAST(
	string key,
	string field,
	string value
) {
  redisPushBinarySafe("HMSET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  redisPushBinarySafe(value);
  return redisCommand();
}

string HSET_NOCAST(
	string key,
	string field,
	string value
) {
  redisPushBinarySafe("HSET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  redisPushBinarySafe(value);
  return redisCommand();
}

string HSETNX_NOCAST(
	string key,
	string field,
	string value
) {
  redisPushBinarySafe("HSETNX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  redisPushBinarySafe(value);
  return redisCommand();
}

string HSTRLEN_NOCAST(
	string key,
	string field
) {
  redisPushBinarySafe("HSTRLEN");
  redisPushBinarySafe(key);
  redisPushBinarySafe(field);
  return redisCommand();
}

string HVALS_NOCAST(
	string key
) {
  redisPushBinarySafe("HVALS");
  redisPushBinarySafe(key);
  return redisCommand();
}

string INCR_NOCAST(
	string key
) {
  redisPushBinarySafe("INCR");
  redisPushBinarySafe(key);
  return redisCommand();
}

string INCRBY_NOCAST(
	string key,
	// Redis type: integer
	string increment
) {
  redisPushBinarySafe("INCRBY");
  redisPushBinarySafe(key);
  redisPushBinarySafe(increment);
  return redisCommand();
}

string INCRBYFLOAT_NOCAST(
	string key,
	// Redis type: double
	string increment
) {
  redisPushBinarySafe("INCRBYFLOAT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(increment);
  return redisCommand();
}

string INFO_NOCAST(
	string section = ""
) {
  redisPushBinarySafe("INFO");
  if (section != "") if (section != "") redisPushBinarySafe(section);
  return redisCommand();
}

string KEYS_NOCAST(
	string pattern
) {
  redisPushBinarySafe("KEYS");
  redisPushBinarySafe(pattern);
  return redisCommand();
}

string LASTSAVE_NOCAST() {
  redisPushBinarySafe("LASTSAVE");
  return redisCommand();
}

string LINDEX_NOCAST(
	string key,
	// Redis type: integer
	string index
) {
  redisPushBinarySafe("LINDEX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(index);
  return redisCommand();
}

string LINSERT_NOCAST(
	string key,
	// Redis type: enum
	string where,
	string pivot,
	string value
) {
  redisPushBinarySafe("LINSERT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(where);
  redisPushBinarySafe(pivot);
  redisPushBinarySafe(value);
  return redisCommand();
}

string LLEN_NOCAST(
	string key
) {
  redisPushBinarySafe("LLEN");
  redisPushBinarySafe(key);
  return redisCommand();
}

string LPOP_NOCAST(
	string key
) {
  redisPushBinarySafe("LPOP");
  redisPushBinarySafe(key);
  return redisCommand();
}

string LPUSH_NOCAST(
	string key,
	string value
) {
  redisPushBinarySafe("LPUSH");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return redisCommand();
}

string LPUSHX_NOCAST(
	string key,
	string value
) {
  redisPushBinarySafe("LPUSHX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return redisCommand();
}

string LRANGE_NOCAST(
	string key,
	// Redis type: integer
	string start,
	// Redis type: integer
	string stop
) {
  redisPushBinarySafe("LRANGE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(start);
  redisPushBinarySafe(stop);
  return redisCommand();
}

string LREM_NOCAST(
	string key,
	// Redis type: integer
	string count,
	string value
) {
  redisPushBinarySafe("LREM");
  redisPushBinarySafe(key);
  redisPushBinarySafe(count);
  redisPushBinarySafe(value);
  return redisCommand();
}

string LSET_NOCAST(
	string key,
	// Redis type: integer
	string index,
	string value
) {
  redisPushBinarySafe("LSET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(index);
  redisPushBinarySafe(value);
  return redisCommand();
}

string LTRIM_NOCAST(
	string key,
	// Redis type: integer
	string start,
	// Redis type: integer
	string stop
) {
  redisPushBinarySafe("LTRIM");
  redisPushBinarySafe(key);
  redisPushBinarySafe(start);
  redisPushBinarySafe(stop);
  return redisCommand();
}

string MGET_NOCAST(
	string key
) {
  redisPushBinarySafe("MGET");
  redisPushBinarySafe(key);
  return redisCommand();
}

string MIGRATE_NOCAST(
	string host,
	string port,
	string key,
	// Redis type: integer
	string destination_db,
	// Redis type: integer
	string timeout,
	// Redis type: enum
	string copy = "",
	// Redis type: enum
	string replace = ""
) {
  redisPushBinarySafe("MIGRATE");
  redisPushBinarySafe(host);
  redisPushBinarySafe(port);
  redisPushBinarySafe(key);
  redisPushBinarySafe(destination_db);
  redisPushBinarySafe(timeout);
  if (copy != "") if (copy != "") redisPushBinarySafe(copy);
  if (replace != "") if (replace != "") redisPushBinarySafe(replace);
  return redisCommand();
}

string MONITOR_NOCAST() {
  redisPushBinarySafe("MONITOR");
  return redisCommand();
}

string MOVE_NOCAST(
	string key,
	// Redis type: integer
	string db
) {
  redisPushBinarySafe("MOVE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(db);
  return redisCommand();
}

string MSET_NOCAST(
	string key,
	string value
) {
  redisPushBinarySafe("MSET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return redisCommand();
}

string MSETNX_NOCAST(
	string key,
	string value
) {
  redisPushBinarySafe("MSETNX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return redisCommand();
}

string MULTI_NOCAST() {
  redisPushBinarySafe("MULTI");
  return redisCommand();
}

string OBJECT_NOCAST(
	string subcommand,
	string arguments = ""
) {
  redisPushBinarySafe("OBJECT");
  redisPushBinarySafe(subcommand);
  if (arguments != "") if (arguments != "") redisPushBinarySafe(arguments);
  return redisCommand();
}

string PERSIST_NOCAST(
	string key
) {
  redisPushBinarySafe("PERSIST");
  redisPushBinarySafe(key);
  return redisCommand();
}

string PEXPIRE_NOCAST(
	string key,
	// Redis type: integer
	string milliseconds
) {
  redisPushBinarySafe("PEXPIRE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(milliseconds);
  return redisCommand();
}

string PEXPIREAT_NOCAST(
	string key,
	// Redis type: posix time
	string milliseconds_timestamp
) {
  redisPushBinarySafe("PEXPIREAT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(milliseconds_timestamp);
  return redisCommand();
}

string PFADD_NOCAST(
	string key,
	string element
) {
  redisPushBinarySafe("PFADD");
  redisPushBinarySafe(key);
  redisPushBinarySafe(element);
  return redisCommand();
}

string PFCOUNT_NOCAST(
	string key
) {
  redisPushBinarySafe("PFCOUNT");
  redisPushBinarySafe(key);
  return redisCommand();
}

string PFMERGE_NOCAST(
	// Redis type: key
	string destkey,
	// Redis type: key
	string sourcekey
) {
  redisPushBinarySafe("PFMERGE");
  redisPushBinarySafe(destkey);
  redisPushBinarySafe(sourcekey);
  return redisCommand();
}

string PING_NOCAST() {
  redisPushBinarySafe("PING");
  return redisCommand();
}

string PSETEX_NOCAST(
	string key,
	// Redis type: integer
	string milliseconds,
	string value
) {
  redisPushBinarySafe("PSETEX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(milliseconds);
  redisPushBinarySafe(value);
  return redisCommand();
}

string PUBSUB_NOCAST(
	string subcommand,
	string argument = ""
) {
  redisPushBinarySafe("PUBSUB");
  redisPushBinarySafe(subcommand);
  if (argument != "") if (argument != "") redisPushBinarySafe(argument);
  return redisCommand();
}

string PTTL_NOCAST(
	string key
) {
  redisPushBinarySafe("PTTL");
  redisPushBinarySafe(key);
  return redisCommand();
}

string PUBLISH_NOCAST(
	string channel,
	string message
) {
  redisPushBinarySafe("PUBLISH");
  redisPushBinarySafe(channel);
  redisPushBinarySafe(message);
  return redisCommand();
}

string QUIT_NOCAST() {
  redisPushBinarySafe("QUIT");
  return redisCommand();
}

string RANDOMKEY_NOCAST() {
  redisPushBinarySafe("RANDOMKEY");
  return redisCommand();
}

string RENAME_NOCAST(
	string key,
	// Redis type: key
	string newkey
) {
  redisPushBinarySafe("RENAME");
  redisPushBinarySafe(key);
  redisPushBinarySafe(newkey);
  return redisCommand();
}

string RENAMENX_NOCAST(
	string key,
	// Redis type: key
	string newkey
) {
  redisPushBinarySafe("RENAMENX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(newkey);
  return redisCommand();
}

string RESTORE_NOCAST(
	string key,
	// Redis type: integer
	string ttl,
	string serialized_value,
	// Redis type: enum
	string replace = ""
) {
  redisPushBinarySafe("RESTORE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(ttl);
  redisPushBinarySafe(serialized_value);
  if (replace != "") if (replace != "") redisPushBinarySafe(replace);
  return redisCommand();
}

string ROLE_NOCAST() {
  redisPushBinarySafe("ROLE");
  return redisCommand();
}

string RPOP_NOCAST(
	string key
) {
  redisPushBinarySafe("RPOP");
  redisPushBinarySafe(key);
  return redisCommand();
}

string RPOPLPUSH_NOCAST(
	// Redis type: key
	string source,
	// Redis type: key
	string destination
) {
  redisPushBinarySafe("RPOPLPUSH");
  redisPushBinarySafe(source);
  redisPushBinarySafe(destination);
  return redisCommand();
}

string RPUSH_NOCAST(
	string key,
	string value
) {
  redisPushBinarySafe("RPUSH");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return redisCommand();
}

string RPUSHX_NOCAST(
	string key,
	string value
) {
  redisPushBinarySafe("RPUSHX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return redisCommand();
}

string SADD_NOCAST(
	string key,
	string member
) {
  redisPushBinarySafe("SADD");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return redisCommand();
}

string SAVE_NOCAST() {
  redisPushBinarySafe("SAVE");
  return redisCommand();
}

string SCARD_NOCAST(
	string key
) {
  redisPushBinarySafe("SCARD");
  redisPushBinarySafe(key);
  return redisCommand();
}

string SCRIPT_EXISTS_NOCAST(
	string script
) {
  redisPushBinarySafe("SCRIPT EXISTS");
  redisPushBinarySafe(script);
  return redisCommand();
}

string SCRIPT_FLUSH_NOCAST() {
  redisPushBinarySafe("SCRIPT FLUSH");
  return redisCommand();
}

string SCRIPT_KILL_NOCAST() {
  redisPushBinarySafe("SCRIPT KILL");
  return redisCommand();
}

string SCRIPT_LOAD_NOCAST(
	string script
) {
  redisPushBinarySafe("SCRIPT LOAD");
  redisPushBinarySafe(script);
  return redisCommand();
}

string SDIFF_NOCAST(
	string key
) {
  redisPushBinarySafe("SDIFF");
  redisPushBinarySafe(key);
  return redisCommand();
}

string SDIFFSTORE_NOCAST(
	// Redis type: key
	string destination,
	string key
) {
  redisPushBinarySafe("SDIFFSTORE");
  redisPushBinarySafe(destination);
  redisPushBinarySafe(key);
  return redisCommand();
}

string SELECT_NOCAST(
	// Redis type: integer
	string index
) {
  redisPushBinarySafe("SELECT");
  redisPushBinarySafe(index);
  return redisCommand();
}

string SET_NOCAST(
	string key,
	string value,
	// Redis type: integer
	string seconds = "",
	// Redis type: integer
	string milliseconds = "",
	// Redis type: enum
	string condition = ""
) {
  redisPushBinarySafe("SET");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  if (seconds != "") if (seconds != "") redisPushBinarySafe(seconds);
  if (milliseconds != "") if (milliseconds != "") redisPushBinarySafe(milliseconds);
  if (condition != "") if (condition != "") redisPushBinarySafe(condition);
  return redisCommand();
}

string SETBIT_NOCAST(
	string key,
	// Redis type: integer
	string offset,
	string value
) {
  redisPushBinarySafe("SETBIT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(offset);
  redisPushBinarySafe(value);
  return redisCommand();
}

string SETEX_NOCAST(
	string key,
	// Redis type: integer
	string seconds,
	string value
) {
  redisPushBinarySafe("SETEX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(seconds);
  redisPushBinarySafe(value);
  return redisCommand();
}

string SETNX_NOCAST(
	string key,
	string value
) {
  redisPushBinarySafe("SETNX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(value);
  return redisCommand();
}

string SETRANGE_NOCAST(
	string key,
	// Redis type: integer
	string offset,
	string value
) {
  redisPushBinarySafe("SETRANGE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(offset);
  redisPushBinarySafe(value);
  return redisCommand();
}

string SHUTDOWN_NOCAST(
	// Redis type: enum
	string NOSAVE = "",
	// Redis type: enum
	string SAVE = ""
) {
  redisPushBinarySafe("SHUTDOWN");
  if (NOSAVE != "") if (NOSAVE != "") redisPushBinarySafe(NOSAVE);
  if (SAVE != "") if (SAVE != "") redisPushBinarySafe(SAVE);
  return redisCommand();
}

string SINTER_NOCAST(
	string key
) {
  redisPushBinarySafe("SINTER");
  redisPushBinarySafe(key);
  return redisCommand();
}

string SINTERSTORE_NOCAST(
	// Redis type: key
	string destination,
	string key
) {
  redisPushBinarySafe("SINTERSTORE");
  redisPushBinarySafe(destination);
  redisPushBinarySafe(key);
  return redisCommand();
}

string SISMEMBER_NOCAST(
	string key,
	string member
) {
  redisPushBinarySafe("SISMEMBER");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return redisCommand();
}

string SLAVEOF_NOCAST(
	string host,
	string port
) {
  redisPushBinarySafe("SLAVEOF");
  redisPushBinarySafe(host);
  redisPushBinarySafe(port);
  return redisCommand();
}

string SLOWLOG_NOCAST(
	string subcommand,
	string argument = ""
) {
  redisPushBinarySafe("SLOWLOG");
  redisPushBinarySafe(subcommand);
  if (argument != "") if (argument != "") redisPushBinarySafe(argument);
  return redisCommand();
}

string SMEMBERS_NOCAST(
	string key
) {
  redisPushBinarySafe("SMEMBERS");
  redisPushBinarySafe(key);
  return redisCommand();
}

string SMOVE_NOCAST(
	// Redis type: key
	string source,
	// Redis type: key
	string destination,
	string member
) {
  redisPushBinarySafe("SMOVE");
  redisPushBinarySafe(source);
  redisPushBinarySafe(destination);
  redisPushBinarySafe(member);
  return redisCommand();
}

string SORT_NOCAST(
	string key,
	string pattern = "",
	// Redis type: integer
	string offset = "",
	// Redis type: integer
	string count = "",
	string pattern = "",
	// Redis type: enum
	string order = "",
	// Redis type: enum
	string sorting = "",
	// Redis type: key
	string destination = ""
) {
  redisPushBinarySafe("SORT");
  redisPushBinarySafe(key);
  if (pattern != "") if (pattern != "") redisPushBinarySafe(pattern);
  if (offset != "") if (offset != "") redisPushBinarySafe(offset);
  if (count != "") if (count != "") redisPushBinarySafe(count);
  if (pattern != "") if (pattern != "") redisPushBinarySafe(pattern);
  if (order != "") if (order != "") redisPushBinarySafe(order);
  if (sorting != "") if (sorting != "") redisPushBinarySafe(sorting);
  if (destination != "") if (destination != "") redisPushBinarySafe(destination);
  return redisCommand();
}

string SPOP_NOCAST(
	string key,
	// Redis type: integer
	string count = ""
) {
  redisPushBinarySafe("SPOP");
  redisPushBinarySafe(key);
  if (count != "") if (count != "") redisPushBinarySafe(count);
  return redisCommand();
}

string SRANDMEMBER_NOCAST(
	string key,
	// Redis type: integer
	string count = ""
) {
  redisPushBinarySafe("SRANDMEMBER");
  redisPushBinarySafe(key);
  if (count != "") if (count != "") redisPushBinarySafe(count);
  return redisCommand();
}

string SREM_NOCAST(
	string key,
	string member
) {
  redisPushBinarySafe("SREM");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return redisCommand();
}

string STRLEN_NOCAST(
	string key
) {
  redisPushBinarySafe("STRLEN");
  redisPushBinarySafe(key);
  return redisCommand();
}

string SUNION_NOCAST(
	string key
) {
  redisPushBinarySafe("SUNION");
  redisPushBinarySafe(key);
  return redisCommand();
}

string SUNIONSTORE_NOCAST(
	// Redis type: key
	string destination,
	string key
) {
  redisPushBinarySafe("SUNIONSTORE");
  redisPushBinarySafe(destination);
  redisPushBinarySafe(key);
  return redisCommand();
}

string SYNC_NOCAST() {
  redisPushBinarySafe("SYNC");
  return redisCommand();
}

string TIME_NOCAST() {
  redisPushBinarySafe("TIME");
  return redisCommand();
}

string TTL_NOCAST(
	string key
) {
  redisPushBinarySafe("TTL");
  redisPushBinarySafe(key);
  return redisCommand();
}

string TYPE_NOCAST(
	string key
) {
  redisPushBinarySafe("TYPE");
  redisPushBinarySafe(key);
  return redisCommand();
}

string UNWATCH_NOCAST() {
  redisPushBinarySafe("UNWATCH");
  return redisCommand();
}

string WAIT_NOCAST(
	// Redis type: integer
	string numslaves,
	// Redis type: integer
	string timeout
) {
  redisPushBinarySafe("WAIT");
  redisPushBinarySafe(numslaves);
  redisPushBinarySafe(timeout);
  return redisCommand();
}

string WATCH_NOCAST(
	string key
) {
  redisPushBinarySafe("WATCH");
  redisPushBinarySafe(key);
  return redisCommand();
}

string ZADD_NOCAST(
	string key,
	// Redis type: enum
	string condition = "",
	// Redis type: enum
	string change = "",
	// Redis type: enum
	string increment = "",
	// Redis type: double
	string score = "",
	string member = ""
) {
  redisPushBinarySafe("ZADD");
  redisPushBinarySafe(key);
  if (condition != "") if (condition != "") redisPushBinarySafe(condition);
  if (change != "") if (change != "") redisPushBinarySafe(change);
  if (increment != "") if (increment != "") redisPushBinarySafe(increment);
  redisPushBinarySafe(score);
  redisPushBinarySafe(member);
  return redisCommand();
}

string ZCARD_NOCAST(
	string key
) {
  redisPushBinarySafe("ZCARD");
  redisPushBinarySafe(key);
  return redisCommand();
}

string ZCOUNT_NOCAST(
	string key,
	// Redis type: double
	string min,
	// Redis type: double
	string max
) {
  redisPushBinarySafe("ZCOUNT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(min);
  redisPushBinarySafe(max);
  return redisCommand();
}

string ZINCRBY_NOCAST(
	string key,
	// Redis type: integer
	string increment,
	string member
) {
  redisPushBinarySafe("ZINCRBY");
  redisPushBinarySafe(key);
  redisPushBinarySafe(increment);
  redisPushBinarySafe(member);
  return redisCommand();
}

string ZINTERSTORE_NOCAST(
	// Redis type: key
	string destination,
	// Redis type: integer
	string numkeys,
	string key,
	// Redis type: integer
	string weight = "",
	// Redis type: enum
	string aggregate = ""
) {
  redisPushBinarySafe("ZINTERSTORE");
  redisPushBinarySafe(destination);
  redisPushBinarySafe(numkeys);
  redisPushBinarySafe(key);
  if (weight != "") if (weight != "") redisPushBinarySafe(weight);
  if (aggregate != "") if (aggregate != "") redisPushBinarySafe(aggregate);
  return redisCommand();
}

string ZLEXCOUNT_NOCAST(
	string key,
	string min,
	string max
) {
  redisPushBinarySafe("ZLEXCOUNT");
  redisPushBinarySafe(key);
  redisPushBinarySafe(min);
  redisPushBinarySafe(max);
  return redisCommand();
}

string ZRANGE_NOCAST(
	string key,
	// Redis type: integer
	string start,
	// Redis type: integer
	string stop,
	// Redis type: enum
	string withscores = ""
) {
  redisPushBinarySafe("ZRANGE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(start);
  redisPushBinarySafe(stop);
  if (withscores != "") if (withscores != "") redisPushBinarySafe(withscores);
  return redisCommand();
}

string ZRANGEBYLEX_NOCAST(
	string key,
	string min,
	string max,
	// Redis type: integer
	string offset = "",
	// Redis type: integer
	string count = ""
) {
  redisPushBinarySafe("ZRANGEBYLEX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(min);
  redisPushBinarySafe(max);
  if (offset != "") if (offset != "") redisPushBinarySafe(offset);
  if (count != "") if (count != "") redisPushBinarySafe(count);
  return redisCommand();
}

string ZREVRANGEBYLEX_NOCAST(
	string key,
	string max,
	string min,
	// Redis type: integer
	string offset = "",
	// Redis type: integer
	string count = ""
) {
  redisPushBinarySafe("ZREVRANGEBYLEX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(max);
  redisPushBinarySafe(min);
  if (offset != "") if (offset != "") redisPushBinarySafe(offset);
  if (count != "") if (count != "") redisPushBinarySafe(count);
  return redisCommand();
}

string ZRANGEBYSCORE_NOCAST(
	string key,
	// Redis type: double
	string min,
	// Redis type: double
	string max,
	// Redis type: enum
	string withscores = "",
	// Redis type: integer
	string offset = "",
	// Redis type: integer
	string count = ""
) {
  redisPushBinarySafe("ZRANGEBYSCORE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(min);
  redisPushBinarySafe(max);
  if (withscores != "") if (withscores != "") redisPushBinarySafe(withscores);
  if (offset != "") if (offset != "") redisPushBinarySafe(offset);
  if (count != "") if (count != "") redisPushBinarySafe(count);
  return redisCommand();
}

string ZRANK_NOCAST(
	string key,
	string member
) {
  redisPushBinarySafe("ZRANK");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return redisCommand();
}

string ZREM_NOCAST(
	string key,
	string member
) {
  redisPushBinarySafe("ZREM");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return redisCommand();
}

string ZREMRANGEBYLEX_NOCAST(
	string key,
	string min,
	string max
) {
  redisPushBinarySafe("ZREMRANGEBYLEX");
  redisPushBinarySafe(key);
  redisPushBinarySafe(min);
  redisPushBinarySafe(max);
  return redisCommand();
}

string ZREMRANGEBYRANK_NOCAST(
	string key,
	// Redis type: integer
	string start,
	// Redis type: integer
	string stop
) {
  redisPushBinarySafe("ZREMRANGEBYRANK");
  redisPushBinarySafe(key);
  redisPushBinarySafe(start);
  redisPushBinarySafe(stop);
  return redisCommand();
}

string ZREMRANGEBYSCORE_NOCAST(
	string key,
	// Redis type: double
	string min,
	// Redis type: double
	string max
) {
  redisPushBinarySafe("ZREMRANGEBYSCORE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(min);
  redisPushBinarySafe(max);
  return redisCommand();
}

string ZREVRANGE_NOCAST(
	string key,
	// Redis type: integer
	string start,
	// Redis type: integer
	string stop,
	// Redis type: enum
	string withscores = ""
) {
  redisPushBinarySafe("ZREVRANGE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(start);
  redisPushBinarySafe(stop);
  if (withscores != "") if (withscores != "") redisPushBinarySafe(withscores);
  return redisCommand();
}

string ZREVRANGEBYSCORE_NOCAST(
	string key,
	// Redis type: double
	string max,
	// Redis type: double
	string min,
	// Redis type: enum
	string withscores = "",
	// Redis type: integer
	string offset = "",
	// Redis type: integer
	string count = ""
) {
  redisPushBinarySafe("ZREVRANGEBYSCORE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(max);
  redisPushBinarySafe(min);
  if (withscores != "") if (withscores != "") redisPushBinarySafe(withscores);
  if (offset != "") if (offset != "") redisPushBinarySafe(offset);
  if (count != "") if (count != "") redisPushBinarySafe(count);
  return redisCommand();
}

string ZREVRANK_NOCAST(
	string key,
	string member
) {
  redisPushBinarySafe("ZREVRANK");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return redisCommand();
}

string ZSCORE_NOCAST(
	string key,
	string member
) {
  redisPushBinarySafe("ZSCORE");
  redisPushBinarySafe(key);
  redisPushBinarySafe(member);
  return redisCommand();
}

string ZUNIONSTORE_NOCAST(
	// Redis type: key
	string destination,
	// Redis type: integer
	string numkeys,
	string key,
	// Redis type: integer
	string weight = "",
	// Redis type: enum
	string aggregate = ""
) {
  redisPushBinarySafe("ZUNIONSTORE");
  redisPushBinarySafe(destination);
  redisPushBinarySafe(numkeys);
  redisPushBinarySafe(key);
  if (weight != "") if (weight != "") redisPushBinarySafe(weight);
  if (aggregate != "") if (aggregate != "") redisPushBinarySafe(aggregate);
  return redisCommand();
}

string SCAN_NOCAST(
	// Redis type: integer
	string cursor,
	string pattern = "",
	// Redis type: integer
	string count = ""
) {
  redisPushBinarySafe("SCAN");
  redisPushBinarySafe(cursor);
  if (pattern != "") if (pattern != "") redisPushBinarySafe(pattern);
  if (count != "") if (count != "") redisPushBinarySafe(count);
  return redisCommand();
}

string SSCAN_NOCAST(
	string key,
	// Redis type: integer
	string cursor,
	string pattern = "",
	// Redis type: integer
	string count = ""
) {
  redisPushBinarySafe("SSCAN");
  redisPushBinarySafe(key);
  redisPushBinarySafe(cursor);
  if (pattern != "") if (pattern != "") redisPushBinarySafe(pattern);
  if (count != "") if (count != "") redisPushBinarySafe(count);
  return redisCommand();
}

string HSCAN_NOCAST(
	string key,
	// Redis type: integer
	string cursor,
	string pattern = "",
	// Redis type: integer
	string count = ""
) {
  redisPushBinarySafe("HSCAN");
  redisPushBinarySafe(key);
  redisPushBinarySafe(cursor);
  if (pattern != "") if (pattern != "") redisPushBinarySafe(pattern);
  if (count != "") if (count != "") redisPushBinarySafe(count);
  return redisCommand();
}

string ZSCAN_NOCAST(
	string key,
	// Redis type: integer
	string cursor,
	string pattern = "",
	// Redis type: integer
	string count = ""
) {
  redisPushBinarySafe("ZSCAN");
  redisPushBinarySafe(key);
  redisPushBinarySafe(cursor);
  if (pattern != "") if (pattern != "") redisPushBinarySafe(pattern);
  if (count != "") if (count != "") redisPushBinarySafe(count);
  return redisCommand();
}

